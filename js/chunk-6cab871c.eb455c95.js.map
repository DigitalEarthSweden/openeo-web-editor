{"version":3,"sources":["webpack:///./node_modules/ol/reproj.js","webpack:///./node_modules/ol/reproj/Triangulation.js","webpack:///./node_modules/ol/reproj/Tile.js","webpack:///./node_modules/ol/size.js","webpack:///./node_modules/ol/rotationconstraint.js","webpack:///./node_modules/ol/reproj/common.js","webpack:///./node_modules/ol/resolutionconstraint.js"],"names":["calculateSourceResolution","sourceProj","targetProj","targetCenter","targetResolution","sourceCenter","sourceResolution","targetMetersPerUnit","getMetersPerUnit","undefined","sourceMetersPerUnit","sourceExtent","getExtent","compensationFactor","isFinite","enlargeClipPoint","centroidX","centroidY","x","y","dX","dY","distance","Math","sqrt","round","render","width","height","pixelRatio","targetExtent","triangulation","sources","gutter","opt_renderEdges","context","length","canvas","scale","sourceDataExtent","forEach","src","i","arr","extent","canvasWidthInUnits","canvasHeightInUnits","stitchContext","stitchScale","xPos","yPos","srcWidth","srcHeight","drawImage","image","targetTopLeft","getTriangles","triangle","source","target","x0","y0","x1","y1","x2","y2","u0","v0","u1","v1","u2","v2","sourceNumericalShiftX","sourceNumericalShiftY","augmentedMatrix","affineCoefs","save","beginPath","p0","p1","p2","moveTo","lineTo","clip","transform","translate","restore","strokeStyle","lineWidth","closePath","stroke","MAX_SUBDIVISION","MAX_TRIANGLE_WIDTH","maxSourceExtent","errorThreshold","this","sourceProj_","targetProj_","transformInvCache","transformInv","transformInv_","c","key","maxSourceExtent_","errorThresholdSquared_","triangles_","wrapsXInSource_","canWrapXInSource_","canWrapX","sourceWorldWidth_","targetWorldWidth_","destinationTopLeft","destinationTopRight","destinationBottomRight","destinationBottomLeft","sourceTopLeft","sourceTopRight","sourceBottomRight","sourceBottomLeft","addQuad_","leftBound","Infinity","min","max","newTriangle","minX","maxX","bind","prototype","addTriangle_","a","b","aSrc","bSrc","cSrc","push","d","dSrc","maxSubdivision","sourceQuadExtent","sourceCoverageX","sourceWorldWidth","wrapsX","needsSubdivision","isGlobal","targetQuadExtent","targetCoverageX","dx","center","centerSrc","centerSrcEstimX","dy","centerSrcErrorSquared","abs","bc","bcSrc","da","daSrc","ab","abSrc","cd","cdSrc","calculateSourceExtent","Tile","ReprojTile","sourceTileGrid","targetTileGrid","tileCoord","wrappedTileCoord","getTileFunction","opt_errorThreshold","call","TileState","IDLE","renderEdges_","pixelRatio_","gutter_","canvas_","sourceTileGrid_","targetTileGrid_","wrappedTileCoord_","sourceTiles_","sourcesListenerKeys_","sourceZ_","getTileCoordExtent","maxTargetExtent","limitedTargetExtent","sourceProjExtent","getResolution","state","EMPTY","errorThresholdInPixels","triangulation_","getZForResolution","sourceRange","getTileRangeForExtentAndZ","srcX","srcY","minY","maxY","tile","__proto__","Object","create","constructor","disposeInternal","LOADING","unlistenSources_","getImage","reproject_","getState","LOADED","ERROR","z","size","getTileSize","changed","load","leftToLoad","sourceListenKey","EventType","CHANGE","e","setTimeout","hasArea","ratio","opt_size","toSize","Array","isArray","disable","rotation","delta","none","createSnapToN","n","theta","PI","floor","createSnapToZero","opt_tolerance","tolerance","ERROR_THRESHOLD","ENABLE_RASTER_REPROJECTION","createSnapToResolutions","resolutions","resolution","direction","index","power","pow","createSnapToPower","maxResolution","opt_maxLevel","offset","oldLevel","log","newLevel"],"mappings":"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","file":"js/chunk-6cab871c.eb455c95.js","sourcesContent":["/**\n * @module ol/reproj\n */\nimport {createCanvasContext2D} from './dom.js';\nimport {containsCoordinate, createEmpty, extend, getHeight, getTopLeft, getWidth} from './extent.js';\nimport {solveLinearSystem} from './math.js';\nimport {getPointResolution, transform} from './proj.js';\n\n\n/**\n * Calculates ideal resolution to use from the source in order to achieve\n * pixel mapping as close as possible to 1:1 during reprojection.\n * The resolution is calculated regardless of what resolutions\n * are actually available in the dataset (TileGrid, Image, ...).\n *\n * @param {import(\"./proj/Projection.js\").default} sourceProj Source projection.\n * @param {import(\"./proj/Projection.js\").default} targetProj Target projection.\n * @param {import(\"./coordinate.js\").Coordinate} targetCenter Target center.\n * @param {number} targetResolution Target resolution.\n * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.\n */\nexport function calculateSourceResolution(sourceProj, targetProj,\n  targetCenter, targetResolution) {\n\n  var sourceCenter = transform(targetCenter, targetProj, sourceProj);\n\n  // calculate the ideal resolution of the source data\n  var sourceResolution = getPointResolution(targetProj, targetResolution, targetCenter);\n\n  var targetMetersPerUnit = targetProj.getMetersPerUnit();\n  if (targetMetersPerUnit !== undefined) {\n    sourceResolution *= targetMetersPerUnit;\n  }\n  var sourceMetersPerUnit = sourceProj.getMetersPerUnit();\n  if (sourceMetersPerUnit !== undefined) {\n    sourceResolution /= sourceMetersPerUnit;\n  }\n\n  // Based on the projection properties, the point resolution at the specified\n  // coordinates may be slightly different. We need to reverse-compensate this\n  // in order to achieve optimal results.\n\n  var sourceExtent = sourceProj.getExtent();\n  if (!sourceExtent || containsCoordinate(sourceExtent, sourceCenter)) {\n    var compensationFactor = getPointResolution(sourceProj, sourceResolution, sourceCenter) /\n        sourceResolution;\n    if (isFinite(compensationFactor) && compensationFactor > 0) {\n      sourceResolution /= compensationFactor;\n    }\n  }\n\n  return sourceResolution;\n}\n\n\n/**\n * Enlarge the clipping triangle point by 1 pixel to ensure the edges overlap\n * in order to mask gaps caused by antialiasing.\n *\n * @param {number} centroidX Centroid of the triangle (x coordinate in pixels).\n * @param {number} centroidY Centroid of the triangle (y coordinate in pixels).\n * @param {number} x X coordinate of the point (in pixels).\n * @param {number} y Y coordinate of the point (in pixels).\n * @return {import(\"./coordinate.js\").Coordinate} New point 1 px farther from the centroid.\n */\nfunction enlargeClipPoint(centroidX, centroidY, x, y) {\n  var dX = x - centroidX;\n  var dY = y - centroidY;\n  var distance = Math.sqrt(dX * dX + dY * dY);\n  return [Math.round(x + dX / distance), Math.round(y + dY / distance)];\n}\n\n\n/**\n * Renders the source data into new canvas based on the triangulation.\n *\n * @param {number} width Width of the canvas.\n * @param {number} height Height of the canvas.\n * @param {number} pixelRatio Pixel ratio.\n * @param {number} sourceResolution Source resolution.\n * @param {import(\"./extent.js\").Extent} sourceExtent Extent of the data source.\n * @param {number} targetResolution Target resolution.\n * @param {import(\"./extent.js\").Extent} targetExtent Target extent.\n * @param {import(\"./reproj/Triangulation.js\").default} triangulation\n * Calculated triangulation.\n * @param {Array<{extent: import(\"./extent.js\").Extent,\n *                 image: (HTMLCanvasElement|HTMLImageElement|HTMLVideoElement)}>} sources\n * Array of sources.\n * @param {number} gutter Gutter of the sources.\n * @param {boolean=} opt_renderEdges Render reprojection edges.\n * @return {HTMLCanvasElement} Canvas with reprojected data.\n */\nexport function render(width, height, pixelRatio,\n  sourceResolution, sourceExtent, targetResolution, targetExtent,\n  triangulation, sources, gutter, opt_renderEdges) {\n\n  var context = createCanvasContext2D(Math.round(pixelRatio * width),\n    Math.round(pixelRatio * height));\n\n  if (sources.length === 0) {\n    return context.canvas;\n  }\n\n  context.scale(pixelRatio, pixelRatio);\n\n  var sourceDataExtent = createEmpty();\n  sources.forEach(function(src, i, arr) {\n    extend(sourceDataExtent, src.extent);\n  });\n\n  var canvasWidthInUnits = getWidth(sourceDataExtent);\n  var canvasHeightInUnits = getHeight(sourceDataExtent);\n  var stitchContext = createCanvasContext2D(\n    Math.round(pixelRatio * canvasWidthInUnits / sourceResolution),\n    Math.round(pixelRatio * canvasHeightInUnits / sourceResolution));\n\n  var stitchScale = pixelRatio / sourceResolution;\n\n  sources.forEach(function(src, i, arr) {\n    var xPos = src.extent[0] - sourceDataExtent[0];\n    var yPos = -(src.extent[3] - sourceDataExtent[3]);\n    var srcWidth = getWidth(src.extent);\n    var srcHeight = getHeight(src.extent);\n\n    stitchContext.drawImage(\n      src.image,\n      gutter, gutter,\n      src.image.width - 2 * gutter, src.image.height - 2 * gutter,\n      xPos * stitchScale, yPos * stitchScale,\n      srcWidth * stitchScale, srcHeight * stitchScale);\n  });\n\n  var targetTopLeft = getTopLeft(targetExtent);\n\n  triangulation.getTriangles().forEach(function(triangle, i, arr) {\n    /* Calculate affine transform (src -> dst)\n     * Resulting matrix can be used to transform coordinate\n     * from `sourceProjection` to destination pixels.\n     *\n     * To optimize number of context calls and increase numerical stability,\n     * we also do the following operations:\n     * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)\n     * here before solving the linear system so [ui, vi] are pixel coordinates.\n     *\n     * Src points: xi, yi\n     * Dst points: ui, vi\n     * Affine coefficients: aij\n     *\n     * | x0 y0 1  0  0 0 |   |a00|   |u0|\n     * | x1 y1 1  0  0 0 |   |a01|   |u1|\n     * | x2 y2 1  0  0 0 | x |a02| = |u2|\n     * |  0  0 0 x0 y0 1 |   |a10|   |v0|\n     * |  0  0 0 x1 y1 1 |   |a11|   |v1|\n     * |  0  0 0 x2 y2 1 |   |a12|   |v2|\n     */\n    var source = triangle.source;\n    var target = triangle.target;\n    var x0 = source[0][0], y0 = source[0][1];\n    var x1 = source[1][0], y1 = source[1][1];\n    var x2 = source[2][0], y2 = source[2][1];\n    var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;\n    var v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;\n    var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;\n    var v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;\n    var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;\n    var v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;\n\n    // Shift all the source points to improve numerical stability\n    // of all the subsequent calculations. The [x0, y0] is used here.\n    // This is also used to simplify the linear system.\n    var sourceNumericalShiftX = x0;\n    var sourceNumericalShiftY = y0;\n    x0 = 0;\n    y0 = 0;\n    x1 -= sourceNumericalShiftX;\n    y1 -= sourceNumericalShiftY;\n    x2 -= sourceNumericalShiftX;\n    y2 -= sourceNumericalShiftY;\n\n    var augmentedMatrix = [\n      [x1, y1, 0, 0, u1 - u0],\n      [x2, y2, 0, 0, u2 - u0],\n      [0, 0, x1, y1, v1 - v0],\n      [0, 0, x2, y2, v2 - v0]\n    ];\n    var affineCoefs = solveLinearSystem(augmentedMatrix);\n    if (!affineCoefs) {\n      return;\n    }\n\n    context.save();\n    context.beginPath();\n    var centroidX = (u0 + u1 + u2) / 3;\n    var centroidY = (v0 + v1 + v2) / 3;\n    var p0 = enlargeClipPoint(centroidX, centroidY, u0, v0);\n    var p1 = enlargeClipPoint(centroidX, centroidY, u1, v1);\n    var p2 = enlargeClipPoint(centroidX, centroidY, u2, v2);\n\n    context.moveTo(p1[0], p1[1]);\n    context.lineTo(p0[0], p0[1]);\n    context.lineTo(p2[0], p2[1]);\n    context.clip();\n\n    context.transform(\n      affineCoefs[0], affineCoefs[2], affineCoefs[1], affineCoefs[3], u0, v0);\n\n    context.translate(sourceDataExtent[0] - sourceNumericalShiftX,\n      sourceDataExtent[3] - sourceNumericalShiftY);\n\n    context.scale(sourceResolution / pixelRatio,\n      -sourceResolution / pixelRatio);\n\n    context.drawImage(stitchContext.canvas, 0, 0);\n    context.restore();\n  });\n\n  if (opt_renderEdges) {\n    context.save();\n\n    context.strokeStyle = 'black';\n    context.lineWidth = 1;\n\n    triangulation.getTriangles().forEach(function(triangle, i, arr) {\n      var target = triangle.target;\n      var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;\n      var v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;\n      var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;\n      var v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;\n      var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;\n      var v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;\n\n      context.beginPath();\n      context.moveTo(u1, v1);\n      context.lineTo(u0, v0);\n      context.lineTo(u2, v2);\n      context.closePath();\n      context.stroke();\n    });\n\n    context.restore();\n  }\n  return context.canvas;\n}\n\n//# sourceMappingURL=reproj.js.map","/**\n * @module ol/reproj/Triangulation\n */\nimport {boundingExtent, createEmpty, extendCoordinate, getBottomLeft, getBottomRight,\n  getTopLeft, getTopRight, getWidth, intersects} from '../extent.js';\nimport {modulo} from '../math.js';\nimport {getTransform} from '../proj.js';\n\n\n/**\n * Single triangle; consists of 3 source points and 3 target points.\n * @typedef {Object} Triangle\n * @property {Array<import(\"../coordinate.js\").Coordinate>} source\n * @property {Array<import(\"../coordinate.js\").Coordinate>} target\n */\n\n\n/**\n * Maximum number of subdivision steps during raster reprojection triangulation.\n * Prevents high memory usage and large number of proj4 calls (for certain\n * transformations and areas). At most `2*(2^this)` triangles are created for\n * each triangulated extent (tile/image).\n * @type {number}\n */\nvar MAX_SUBDIVISION = 10;\n\n\n/**\n * Maximum allowed size of triangle relative to world width. When transforming\n * corners of world extent between certain projections, the resulting\n * triangulation seems to have zero error and no subdivision is performed. If\n * the triangle width is more than this (relative to world width; 0-1),\n * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.\n * @type {number}\n */\nvar MAX_TRIANGLE_WIDTH = 0.25;\n\n\n/**\n * @classdesc\n * Class containing triangulation of the given target extent.\n * Used for determining source data and the reprojection itself.\n */\nvar Triangulation = function Triangulation(sourceProj, targetProj, targetExtent, maxSourceExtent, errorThreshold) {\n\n  /**\n   * @type {import(\"../proj/Projection.js\").default}\n   * @private\n   */\n  this.sourceProj_ = sourceProj;\n\n  /**\n   * @type {import(\"../proj/Projection.js\").default}\n   * @private\n   */\n  this.targetProj_ = targetProj;\n\n  /** @type {!Object<string, import(\"../coordinate.js\").Coordinate>} */\n  var transformInvCache = {};\n  var transformInv = getTransform(this.targetProj_, this.sourceProj_);\n\n  /**\n   * @param {import(\"../coordinate.js\").Coordinate} c A coordinate.\n   * @return {import(\"../coordinate.js\").Coordinate} Transformed coordinate.\n   * @private\n   */\n  this.transformInv_ = function(c) {\n    var key = c[0] + '/' + c[1];\n    if (!transformInvCache[key]) {\n      transformInvCache[key] = transformInv(c);\n    }\n    return transformInvCache[key];\n  };\n\n  /**\n   * @type {import(\"../extent.js\").Extent}\n   * @private\n   */\n  this.maxSourceExtent_ = maxSourceExtent;\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.errorThresholdSquared_ = errorThreshold * errorThreshold;\n\n  /**\n   * @type {Array<Triangle>}\n   * @private\n   */\n  this.triangles_ = [];\n\n  /**\n   * Indicates that the triangulation crosses edge of the source projection.\n   * @type {boolean}\n   * @private\n   */\n  this.wrapsXInSource_ = false;\n\n  /**\n   * @type {boolean}\n   * @private\n   */\n  this.canWrapXInSource_ = this.sourceProj_.canWrapX() &&\n      !!maxSourceExtent &&\n      !!this.sourceProj_.getExtent() &&\n      (getWidth(maxSourceExtent) == getWidth(this.sourceProj_.getExtent()));\n\n  /**\n   * @type {?number}\n   * @private\n   */\n  this.sourceWorldWidth_ = this.sourceProj_.getExtent() ?\n    getWidth(this.sourceProj_.getExtent()) : null;\n\n  /**\n   * @type {?number}\n   * @private\n   */\n  this.targetWorldWidth_ = this.targetProj_.getExtent() ?\n    getWidth(this.targetProj_.getExtent()) : null;\n\n  var destinationTopLeft = getTopLeft(targetExtent);\n  var destinationTopRight = getTopRight(targetExtent);\n  var destinationBottomRight = getBottomRight(targetExtent);\n  var destinationBottomLeft = getBottomLeft(targetExtent);\n  var sourceTopLeft = this.transformInv_(destinationTopLeft);\n  var sourceTopRight = this.transformInv_(destinationTopRight);\n  var sourceBottomRight = this.transformInv_(destinationBottomRight);\n  var sourceBottomLeft = this.transformInv_(destinationBottomLeft);\n\n  this.addQuad_(\n    destinationTopLeft, destinationTopRight,\n    destinationBottomRight, destinationBottomLeft,\n    sourceTopLeft, sourceTopRight, sourceBottomRight, sourceBottomLeft,\n    MAX_SUBDIVISION);\n\n  if (this.wrapsXInSource_) {\n    var leftBound = Infinity;\n    this.triangles_.forEach(function(triangle, i, arr) {\n      leftBound = Math.min(leftBound,\n        triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]);\n    });\n\n    // Shift triangles to be as close to `leftBound` as possible\n    // (if the distance is more than `worldWidth / 2` it can be closer.\n    this.triangles_.forEach(function(triangle) {\n      if (Math.max(triangle.source[0][0], triangle.source[1][0],\n        triangle.source[2][0]) - leftBound > this.sourceWorldWidth_ / 2) {\n        var newTriangle = [[triangle.source[0][0], triangle.source[0][1]],\n          [triangle.source[1][0], triangle.source[1][1]],\n          [triangle.source[2][0], triangle.source[2][1]]];\n        if ((newTriangle[0][0] - leftBound) > this.sourceWorldWidth_ / 2) {\n          newTriangle[0][0] -= this.sourceWorldWidth_;\n        }\n        if ((newTriangle[1][0] - leftBound) > this.sourceWorldWidth_ / 2) {\n          newTriangle[1][0] -= this.sourceWorldWidth_;\n        }\n        if ((newTriangle[2][0] - leftBound) > this.sourceWorldWidth_ / 2) {\n          newTriangle[2][0] -= this.sourceWorldWidth_;\n        }\n\n        // Rarely (if the extent contains both the dateline and prime meridian)\n        // the shift can in turn break some triangles.\n        // Detect this here and don't shift in such cases.\n        var minX = Math.min(\n          newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);\n        var maxX = Math.max(\n          newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);\n        if ((maxX - minX) < this.sourceWorldWidth_ / 2) {\n          triangle.source = newTriangle;\n        }\n      }\n    }.bind(this));\n  }\n\n  transformInvCache = {};\n};\n\n/**\n * Adds triangle to the triangulation.\n * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n * @private\n */\nTriangulation.prototype.addTriangle_ = function addTriangle_ (a, b, c, aSrc, bSrc, cSrc) {\n  this.triangles_.push({\n    source: [aSrc, bSrc, cSrc],\n    target: [a, b, c]\n  });\n};\n\n/**\n * Adds quad (points in clock-wise order) to the triangulation\n * (and reprojects the vertices) if valid.\n * Performs quad subdivision if needed to increase precision.\n *\n * @param {import(\"../coordinate.js\").Coordinate} a The target a coordinate.\n * @param {import(\"../coordinate.js\").Coordinate} b The target b coordinate.\n * @param {import(\"../coordinate.js\").Coordinate} c The target c coordinate.\n * @param {import(\"../coordinate.js\").Coordinate} d The target d coordinate.\n * @param {import(\"../coordinate.js\").Coordinate} aSrc The source a coordinate.\n * @param {import(\"../coordinate.js\").Coordinate} bSrc The source b coordinate.\n * @param {import(\"../coordinate.js\").Coordinate} cSrc The source c coordinate.\n * @param {import(\"../coordinate.js\").Coordinate} dSrc The source d coordinate.\n * @param {number} maxSubdivision Maximal allowed subdivision of the quad.\n * @private\n */\nTriangulation.prototype.addQuad_ = function addQuad_ (a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {\n\n  var sourceQuadExtent = boundingExtent([aSrc, bSrc, cSrc, dSrc]);\n  var sourceCoverageX = this.sourceWorldWidth_ ?\n    getWidth(sourceQuadExtent) / this.sourceWorldWidth_ : null;\n  var sourceWorldWidth = /** @type {number} */ (this.sourceWorldWidth_);\n\n  // when the quad is wrapped in the source projection\n  // it covers most of the projection extent, but not fully\n  var wrapsX = this.sourceProj_.canWrapX() &&\n               sourceCoverageX > 0.5 && sourceCoverageX < 1;\n\n  var needsSubdivision = false;\n\n  if (maxSubdivision > 0) {\n    if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {\n      var targetQuadExtent = boundingExtent([a, b, c, d]);\n      var targetCoverageX = getWidth(targetQuadExtent) / this.targetWorldWidth_;\n      needsSubdivision = targetCoverageX > MAX_TRIANGLE_WIDTH ||\n        needsSubdivision;\n    }\n    if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {\n      needsSubdivision = sourceCoverageX > MAX_TRIANGLE_WIDTH ||\n          needsSubdivision;\n    }\n  }\n\n  if (!needsSubdivision && this.maxSourceExtent_) {\n    if (!intersects(sourceQuadExtent, this.maxSourceExtent_)) {\n      // whole quad outside source projection extent -> ignore\n      return;\n    }\n  }\n\n  if (!needsSubdivision) {\n    if (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ||\n        !isFinite(bSrc[0]) || !isFinite(bSrc[1]) ||\n        !isFinite(cSrc[0]) || !isFinite(cSrc[1]) ||\n        !isFinite(dSrc[0]) || !isFinite(dSrc[1])) {\n      if (maxSubdivision > 0) {\n        needsSubdivision = true;\n      } else {\n        return;\n      }\n    }\n  }\n\n  if (maxSubdivision > 0) {\n    if (!needsSubdivision) {\n      var center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];\n      var centerSrc = this.transformInv_(center);\n\n      var dx;\n      if (wrapsX) {\n        var centerSrcEstimX =\n            (modulo(aSrc[0], sourceWorldWidth) +\n             modulo(cSrc[0], sourceWorldWidth)) / 2;\n        dx = centerSrcEstimX -\n            modulo(centerSrc[0], sourceWorldWidth);\n      } else {\n        dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];\n      }\n      var dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];\n      var centerSrcErrorSquared = dx * dx + dy * dy;\n      needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;\n    }\n    if (needsSubdivision) {\n      if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {\n        // split horizontally (top & bottom)\n        var bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];\n        var bcSrc = this.transformInv_(bc);\n        var da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];\n        var daSrc = this.transformInv_(da);\n\n        this.addQuad_(\n          a, b, bc, da, aSrc, bSrc, bcSrc, daSrc, maxSubdivision - 1);\n        this.addQuad_(\n          da, bc, c, d, daSrc, bcSrc, cSrc, dSrc, maxSubdivision - 1);\n      } else {\n        // split vertically (left & right)\n        var ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];\n        var abSrc = this.transformInv_(ab);\n        var cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];\n        var cdSrc = this.transformInv_(cd);\n\n        this.addQuad_(\n          a, ab, cd, d, aSrc, abSrc, cdSrc, dSrc, maxSubdivision - 1);\n        this.addQuad_(\n          ab, b, c, cd, abSrc, bSrc, cSrc, cdSrc, maxSubdivision - 1);\n      }\n      return;\n    }\n  }\n\n  if (wrapsX) {\n    if (!this.canWrapXInSource_) {\n      return;\n    }\n    this.wrapsXInSource_ = true;\n  }\n\n  this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);\n  this.addTriangle_(a, b, c, aSrc, bSrc, cSrc);\n};\n\n/**\n * Calculates extent of the 'source' coordinates from all the triangles.\n *\n * @return {import(\"../extent.js\").Extent} Calculated extent.\n */\nTriangulation.prototype.calculateSourceExtent = function calculateSourceExtent () {\n  var extent = createEmpty();\n\n  this.triangles_.forEach(function(triangle, i, arr) {\n    var src = triangle.source;\n    extendCoordinate(extent, src[0]);\n    extendCoordinate(extent, src[1]);\n    extendCoordinate(extent, src[2]);\n  });\n\n  return extent;\n};\n\n/**\n * @return {Array<Triangle>} Array of the calculated triangles.\n */\nTriangulation.prototype.getTriangles = function getTriangles () {\n  return this.triangles_;\n};\n\nexport default Triangulation;\n\n//# sourceMappingURL=Triangulation.js.map","/**\n * @module ol/reproj/Tile\n */\nimport {ERROR_THRESHOLD} from './common.js';\n\nimport Tile from '../Tile.js';\nimport TileState from '../TileState.js';\nimport {listen, unlistenByKey} from '../events.js';\nimport EventType from '../events/EventType.js';\nimport {getArea, getCenter, getIntersection} from '../extent.js';\nimport {clamp} from '../math.js';\nimport {calculateSourceResolution, render as renderReprojected} from '../reproj.js';\nimport Triangulation from './Triangulation.js';\n\n\n/**\n * @typedef {function(number, number, number, number) : import(\"../Tile.js\").default} FunctionType\n */\n\n\n/**\n * @classdesc\n * Class encapsulating single reprojected tile.\n * See {@link module:ol/source/TileImage~TileImage}.\n *\n */\nvar ReprojTile = /*@__PURE__*/(function (Tile) {\n  function ReprojTile(\n    sourceProj,\n    sourceTileGrid,\n    targetProj,\n    targetTileGrid,\n    tileCoord,\n    wrappedTileCoord,\n    pixelRatio,\n    gutter,\n    getTileFunction,\n    opt_errorThreshold,\n    opt_renderEdges\n  ) {\n    Tile.call(this, tileCoord, TileState.IDLE);\n\n    /**\n     * @private\n     * @type {boolean}\n     */\n    this.renderEdges_ = opt_renderEdges !== undefined ? opt_renderEdges : false;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.pixelRatio_ = pixelRatio;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.gutter_ = gutter;\n\n    /**\n     * @private\n     * @type {HTMLCanvasElement}\n     */\n    this.canvas_ = null;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.sourceTileGrid_ = sourceTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilegrid/TileGrid.js\").default}\n     */\n    this.targetTileGrid_ = targetTileGrid;\n\n    /**\n     * @private\n     * @type {import(\"../tilecoord.js\").TileCoord}\n     */\n    this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;\n\n    /**\n     * @private\n     * @type {!Array<import(\"../Tile.js\").default>}\n     */\n    this.sourceTiles_ = [];\n\n    /**\n     * @private\n     * @type {Array<import(\"../events.js\").EventsKey>}\n     */\n    this.sourcesListenerKeys_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.sourceZ_ = 0;\n\n    var targetExtent = targetTileGrid.getTileCoordExtent(this.wrappedTileCoord_);\n    var maxTargetExtent = this.targetTileGrid_.getExtent();\n    var maxSourceExtent = this.sourceTileGrid_.getExtent();\n\n    var limitedTargetExtent = maxTargetExtent ?\n      getIntersection(targetExtent, maxTargetExtent) : targetExtent;\n\n    if (getArea(limitedTargetExtent) === 0) {\n      // Tile is completely outside range -> EMPTY\n      // TODO: is it actually correct that the source even creates the tile ?\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    var sourceProjExtent = sourceProj.getExtent();\n    if (sourceProjExtent) {\n      if (!maxSourceExtent) {\n        maxSourceExtent = sourceProjExtent;\n      } else {\n        maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);\n      }\n    }\n\n    var targetResolution = targetTileGrid.getResolution(\n      this.wrappedTileCoord_[0]);\n\n    var targetCenter = getCenter(limitedTargetExtent);\n    var sourceResolution = calculateSourceResolution(\n      sourceProj, targetProj, targetCenter, targetResolution);\n\n    if (!isFinite(sourceResolution) || sourceResolution <= 0) {\n      // invalid sourceResolution -> EMPTY\n      // probably edges of the projections when no extent is defined\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    var errorThresholdInPixels = opt_errorThreshold !== undefined ?\n      opt_errorThreshold : ERROR_THRESHOLD;\n\n    /**\n     * @private\n     * @type {!import(\"./Triangulation.js\").default}\n     */\n    this.triangulation_ = new Triangulation(\n      sourceProj, targetProj, limitedTargetExtent, maxSourceExtent,\n      sourceResolution * errorThresholdInPixels);\n\n    if (this.triangulation_.getTriangles().length === 0) {\n      // no valid triangles -> EMPTY\n      this.state = TileState.EMPTY;\n      return;\n    }\n\n    this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);\n    var sourceExtent = this.triangulation_.calculateSourceExtent();\n\n    if (maxSourceExtent) {\n      if (sourceProj.canWrapX()) {\n        sourceExtent[1] = clamp(\n          sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);\n        sourceExtent[3] = clamp(\n          sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);\n      } else {\n        sourceExtent = getIntersection(sourceExtent, maxSourceExtent);\n      }\n    }\n\n    if (!getArea(sourceExtent)) {\n      this.state = TileState.EMPTY;\n    } else {\n      var sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(\n        sourceExtent, this.sourceZ_);\n\n      for (var srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {\n        for (var srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {\n          var tile = getTileFunction(this.sourceZ_, srcX, srcY, pixelRatio);\n          if (tile) {\n            this.sourceTiles_.push(tile);\n          }\n        }\n      }\n\n      if (this.sourceTiles_.length === 0) {\n        this.state = TileState.EMPTY;\n      }\n    }\n  }\n\n  if ( Tile ) ReprojTile.__proto__ = Tile;\n  ReprojTile.prototype = Object.create( Tile && Tile.prototype );\n  ReprojTile.prototype.constructor = ReprojTile;\n\n  /**\n   * @inheritDoc\n   */\n  ReprojTile.prototype.disposeInternal = function disposeInternal () {\n    if (this.state == TileState.LOADING) {\n      this.unlistenSources_();\n    }\n    Tile.prototype.disposeInternal.call(this);\n  };\n\n  /**\n   * Get the HTML Canvas element for this tile.\n   * @return {HTMLCanvasElement} Canvas.\n   */\n  ReprojTile.prototype.getImage = function getImage () {\n    return this.canvas_;\n  };\n\n  /**\n   * @private\n   */\n  ReprojTile.prototype.reproject_ = function reproject_ () {\n    var sources = [];\n    this.sourceTiles_.forEach(function(tile, i, arr) {\n      if (tile && tile.getState() == TileState.LOADED) {\n        sources.push({\n          extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),\n          image: tile.getImage()\n        });\n      }\n    }.bind(this));\n    this.sourceTiles_.length = 0;\n\n    if (sources.length === 0) {\n      this.state = TileState.ERROR;\n    } else {\n      var z = this.wrappedTileCoord_[0];\n      var size = this.targetTileGrid_.getTileSize(z);\n      var width = typeof size === 'number' ? size : size[0];\n      var height = typeof size === 'number' ? size : size[1];\n      var targetResolution = this.targetTileGrid_.getResolution(z);\n      var sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);\n\n      var targetExtent = this.targetTileGrid_.getTileCoordExtent(\n        this.wrappedTileCoord_);\n      this.canvas_ = renderReprojected(width, height, this.pixelRatio_,\n        sourceResolution, this.sourceTileGrid_.getExtent(),\n        targetResolution, targetExtent, this.triangulation_, sources,\n        this.gutter_, this.renderEdges_);\n\n      this.state = TileState.LOADED;\n    }\n    this.changed();\n  };\n\n  /**\n   * @inheritDoc\n   */\n  ReprojTile.prototype.load = function load () {\n    if (this.state == TileState.IDLE) {\n      this.state = TileState.LOADING;\n      this.changed();\n\n      var leftToLoad = 0;\n\n      this.sourcesListenerKeys_ = [];\n      this.sourceTiles_.forEach(function(tile, i, arr) {\n        var state = tile.getState();\n        if (state == TileState.IDLE || state == TileState.LOADING) {\n          leftToLoad++;\n\n          var sourceListenKey = listen(tile, EventType.CHANGE,\n            function(e) {\n              var state = tile.getState();\n              if (state == TileState.LOADED ||\n                    state == TileState.ERROR ||\n                    state == TileState.EMPTY) {\n                unlistenByKey(sourceListenKey);\n                leftToLoad--;\n                if (leftToLoad === 0) {\n                  this.unlistenSources_();\n                  this.reproject_();\n                }\n              }\n            }, this);\n          this.sourcesListenerKeys_.push(sourceListenKey);\n        }\n      }.bind(this));\n\n      this.sourceTiles_.forEach(function(tile, i, arr) {\n        var state = tile.getState();\n        if (state == TileState.IDLE) {\n          tile.load();\n        }\n      });\n\n      if (leftToLoad === 0) {\n        setTimeout(this.reproject_.bind(this), 0);\n      }\n    }\n  };\n\n  /**\n   * @private\n   */\n  ReprojTile.prototype.unlistenSources_ = function unlistenSources_ () {\n    this.sourcesListenerKeys_.forEach(unlistenByKey);\n    this.sourcesListenerKeys_ = null;\n  };\n\n  return ReprojTile;\n}(Tile));\n\n\nexport default ReprojTile;\n\n//# sourceMappingURL=Tile.js.map","/**\n * @module ol/size\n */\n\n\n/**\n * An array of numbers representing a size: `[width, height]`.\n * @typedef {Array<number>} Size\n * @api\n */\n\n\n/**\n * Returns a buffered size.\n * @param {Size} size Size.\n * @param {number} num The amount by which to buffer.\n * @param {Size=} opt_size Optional reusable size array.\n * @return {Size} The buffered size.\n */\nexport function buffer(size, num, opt_size) {\n  if (opt_size === undefined) {\n    opt_size = [0, 0];\n  }\n  opt_size[0] = size[0] + 2 * num;\n  opt_size[1] = size[1] + 2 * num;\n  return opt_size;\n}\n\n\n/**\n * Determines if a size has a positive area.\n * @param {Size} size The size to test.\n * @return {boolean} The size has a positive area.\n */\nexport function hasArea(size) {\n  return size[0] > 0 && size[1] > 0;\n}\n\n\n/**\n * Returns a size scaled by a ratio. The result will be an array of integers.\n * @param {Size} size Size.\n * @param {number} ratio Ratio.\n * @param {Size=} opt_size Optional reusable size array.\n * @return {Size} The scaled size.\n */\nexport function scale(size, ratio, opt_size) {\n  if (opt_size === undefined) {\n    opt_size = [0, 0];\n  }\n  opt_size[0] = (size[0] * ratio + 0.5) | 0;\n  opt_size[1] = (size[1] * ratio + 0.5) | 0;\n  return opt_size;\n}\n\n\n/**\n * Returns an `Size` array for the passed in number (meaning: square) or\n * `Size` array.\n * (meaning: non-square),\n * @param {number|Size} size Width and height.\n * @param {Size=} opt_size Optional reusable size array.\n * @return {Size} Size.\n * @api\n */\nexport function toSize(size, opt_size) {\n  if (Array.isArray(size)) {\n    return size;\n  } else {\n    if (opt_size === undefined) {\n      opt_size = [size, size];\n    } else {\n      opt_size[0] = opt_size[1] = /** @type {number} */ (size);\n    }\n    return opt_size;\n  }\n}\n\n//# sourceMappingURL=size.js.map","/**\n * @module ol/rotationconstraint\n */\nimport {toRadians} from './math.js';\n\n\n/**\n * @typedef {function((number|undefined), number): (number|undefined)} Type\n */\n\n\n/**\n * @param {number|undefined} rotation Rotation.\n * @param {number} delta Delta.\n * @return {number|undefined} Rotation.\n */\nexport function disable(rotation, delta) {\n  if (rotation !== undefined) {\n    return 0;\n  } else {\n    return undefined;\n  }\n}\n\n\n/**\n * @param {number|undefined} rotation Rotation.\n * @param {number} delta Delta.\n * @return {number|undefined} Rotation.\n */\nexport function none(rotation, delta) {\n  if (rotation !== undefined) {\n    return rotation + delta;\n  } else {\n    return undefined;\n  }\n}\n\n\n/**\n * @param {number} n N.\n * @return {Type} Rotation constraint.\n */\nexport function createSnapToN(n) {\n  var theta = 2 * Math.PI / n;\n  return (\n    /**\n     * @param {number|undefined} rotation Rotation.\n     * @param {number} delta Delta.\n     * @return {number|undefined} Rotation.\n     */\n    function(rotation, delta) {\n      if (rotation !== undefined) {\n        rotation = Math.floor((rotation + delta) / theta + 0.5) * theta;\n        return rotation;\n      } else {\n        return undefined;\n      }\n    });\n}\n\n\n/**\n * @param {number=} opt_tolerance Tolerance.\n * @return {Type} Rotation constraint.\n */\nexport function createSnapToZero(opt_tolerance) {\n  var tolerance = opt_tolerance || toRadians(5);\n  return (\n    /**\n     * @param {number|undefined} rotation Rotation.\n     * @param {number} delta Delta.\n     * @return {number|undefined} Rotation.\n     */\n    function(rotation, delta) {\n      if (rotation !== undefined) {\n        if (Math.abs(rotation + delta) <= tolerance) {\n          return 0;\n        } else {\n          return rotation + delta;\n        }\n      } else {\n        return undefined;\n      }\n    });\n}\n\n//# sourceMappingURL=rotationconstraint.js.map","/**\n * @module ol/reproj/common\n */\n\n/**\n * Default maximum allowed threshold  (in pixels) for reprojection\n * triangulation.\n * @type {number}\n */\nexport var ERROR_THRESHOLD = 0.5;\n\n/**\n * Enable automatic reprojection of raster sources. Default is `true`.\n * TODO: decide if we want to expose this as a build flag or remove it\n * @type {boolean}\n */\nexport var ENABLE_RASTER_REPROJECTION = true;\n\n//# sourceMappingURL=common.js.map","/**\n * @module ol/resolutionconstraint\n */\nimport {linearFindNearest} from './array.js';\nimport {clamp} from './math.js';\n\n\n/**\n * @typedef {function((number|undefined), number, number): (number|undefined)} Type\n */\n\n\n/**\n * @param {Array<number>} resolutions Resolutions.\n * @return {Type} Zoom function.\n */\nexport function createSnapToResolutions(resolutions) {\n  return (\n    /**\n     * @param {number|undefined} resolution Resolution.\n     * @param {number} delta Delta.\n     * @param {number} direction Direction.\n     * @return {number|undefined} Resolution.\n     */\n    function(resolution, delta, direction) {\n      if (resolution !== undefined) {\n        var z = linearFindNearest(resolutions, resolution, direction);\n        z = clamp(z + delta, 0, resolutions.length - 1);\n        var index = Math.floor(z);\n        if (z != index && index < resolutions.length - 1) {\n          var power = resolutions[index] / resolutions[index + 1];\n          return resolutions[index] / Math.pow(power, z - index);\n        } else {\n          return resolutions[index];\n        }\n      } else {\n        return undefined;\n      }\n    }\n  );\n}\n\n\n/**\n * @param {number} power Power.\n * @param {number} maxResolution Maximum resolution.\n * @param {number=} opt_maxLevel Maximum level.\n * @return {Type} Zoom function.\n */\nexport function createSnapToPower(power, maxResolution, opt_maxLevel) {\n  return (\n    /**\n     * @param {number|undefined} resolution Resolution.\n     * @param {number} delta Delta.\n     * @param {number} direction Direction.\n     * @return {number|undefined} Resolution.\n     */\n    function(resolution, delta, direction) {\n      if (resolution !== undefined) {\n        var offset = -direction / 2 + 0.5;\n        var oldLevel = Math.floor(\n          Math.log(maxResolution / resolution) / Math.log(power) + offset);\n        var newLevel = Math.max(oldLevel + delta, 0);\n        if (opt_maxLevel !== undefined) {\n          newLevel = Math.min(newLevel, opt_maxLevel);\n        }\n        return maxResolution / Math.pow(power, newLevel);\n      } else {\n        return undefined;\n      }\n    });\n}\n\n//# sourceMappingURL=resolutionconstraint.js.map"],"sourceRoot":""}