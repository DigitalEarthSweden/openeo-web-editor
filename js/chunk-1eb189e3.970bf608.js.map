{"version":3,"sources":["webpack:///./node_modules/ol/tilegrid/common.js","webpack:///./node_modules/ol/tilegrid.js","webpack:///./node_modules/ol/util.js","webpack:///./node_modules/ol/tilecoord.js","webpack:///./node_modules/ol/tilegrid/TileGrid.js","webpack:///./node_modules/ol/tileurlfunction.js","webpack:///./node_modules/ol/transform.js"],"names":["DEFAULT_MAX_ZOOM","DEFAULT_TILE_SIZE","getForProjection","projection","tileGrid","getDefaultTileGrid","createForProjection","setDefaultTileGrid","wrapX","tileCoord","z","center","getTileCoordCenter","projectionExtent","extentFromProjection","worldWidth","worldsAway","Math","ceil","getTileCoordForCoordAndZ","createForExtent","extent","opt_maxZoom","opt_tileSize","opt_corner","corner","undefined","TOP_LEFT","resolutions","resolutionsFromExtent","origin","tileSize","createXYZ","opt_options","xyzOptions","getExtent","gridOptions","minZoom","maxZoom","height","width","maxResolution","max","length","Array","pow","half","DEGREES","getMetersPerUnit","abstract","Error","uidCounter_","getUid","obj","ol_uid","String","VERSION","createOrUpdate","x","y","opt_tileCoord","getKeyZXY","getKey","fromKey","key","split","map","Number","hash","withinExtentAndZ","getMinZoom","getMaxZoom","tileRange","getTileRangeForExtentAndZ","getFullTileRange","containsXY","tmpTileCoord","TileGrid","options","zoomFactor","this","resolutions_","a","b","origins","i","ii","zoomFactor_","origin_","origins_","tileSizes_","tileSizes","tileSize_","extent_","fullTileRanges_","tmpSize_","sizes","size","min","calculateTileRanges_","prototype","forEachTileCoord","zoom","callback","minX","maxX","j","minY","jj","maxY","forEachTileCoordParentTileRange","opt_this","opt_tileRange","opt_extent","tileCoordExtent","getTileCoordExtent","floor","call","getOrigin","getResolution","getResolutions","getTileCoordChildTileRange","getTileRangeExtent","resolution","getTileSize","getTileCoordForXYAndZ_","getTileCoordForCoordAndResolution","coordinate","getTileCoordForXYAndResolution_","reverseIntersectionPolicy","getZForResolution","scale","adjustX","adjustY","xFromOrigin","yFromOrigin","tileCoordX","tileCoordY","getTileCoordResolution","opt_direction","fullTileRanges","createFromTemplate","template","zRegEx","xRegEx","yRegEx","dashYRegEx","pixelRatio","replace","toString","range","getHeight","createFromTemplates","templates","len","tileUrlFunctions","createFromTileUrlFunctions","h","index","nullTileUrlFunction","expandUrl","url","urls","match","exec","charCode","startCharCode","charCodeAt","stopCharCode","push","fromCharCode","stop","parseInt","tmp_","create","reset","transform","set","multiply","transform1","transform2","a1","b1","c1","d1","e1","f1","a2","b2","c2","d2","e2","f2","c","d","e","f","setFromArray","apply","translate","dx","dy","compose","dx1","dy1","sx","sy","angle","dx2","dy2","sin","cos","invert","det","determinant","mat"],"mappings":"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","file":"js/chunk-1eb189e3.970bf608.js","sourcesContent":["/**\n * @module ol/tilegrid/common\n */\n\n/**\n * Default maximum zoom for default tile grids.\n * @type {number}\n */\nexport var DEFAULT_MAX_ZOOM = 42;\n\n/**\n * Default tile size.\n * @type {number}\n */\nexport var DEFAULT_TILE_SIZE = 256;\n\n//# sourceMappingURL=common.js.map","/**\n * @module ol/tilegrid\n */\nimport {DEFAULT_MAX_ZOOM, DEFAULT_TILE_SIZE} from './tilegrid/common.js';\nimport {toSize} from './size.js';\nimport {containsCoordinate, createOrUpdate, getCorner, getHeight, getWidth} from './extent.js';\nimport Corner from './extent/Corner.js';\nimport {get as getProjection, METERS_PER_UNIT} from './proj.js';\nimport Units from './proj/Units.js';\nimport TileGrid from './tilegrid/TileGrid.js';\n\n\n/**\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {!TileGrid} Default tile grid for the\n * passed projection.\n */\nexport function getForProjection(projection) {\n  var tileGrid = projection.getDefaultTileGrid();\n  if (!tileGrid) {\n    tileGrid = createForProjection(projection);\n    projection.setDefaultTileGrid(tileGrid);\n  }\n  return tileGrid;\n}\n\n\n/**\n * @param {TileGrid} tileGrid Tile grid.\n * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {import(\"./tilecoord.js\").TileCoord} Tile coordinate.\n */\nexport function wrapX(tileGrid, tileCoord, projection) {\n  var z = tileCoord[0];\n  var center = tileGrid.getTileCoordCenter(tileCoord);\n  var projectionExtent = extentFromProjection(projection);\n  if (!containsCoordinate(projectionExtent, center)) {\n    var worldWidth = getWidth(projectionExtent);\n    var worldsAway = Math.ceil((projectionExtent[0] - center[0]) / worldWidth);\n    center[0] += worldWidth * worldsAway;\n    return tileGrid.getTileCoordForCoordAndZ(center, z);\n  } else {\n    return tileCoord;\n  }\n}\n\n\n/**\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {number=} opt_maxZoom Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import(\"./size.js\").Size=} opt_tileSize Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {Corner=} opt_corner Extent corner (default is `'top-left'`).\n * @return {!TileGrid} TileGrid instance.\n */\nexport function createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner) {\n  var corner = opt_corner !== undefined ? opt_corner : Corner.TOP_LEFT;\n\n  var resolutions = resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize);\n\n  return new TileGrid({\n    extent: extent,\n    origin: getCorner(extent, corner),\n    resolutions: resolutions,\n    tileSize: opt_tileSize\n  });\n}\n\n\n/**\n * @typedef {Object} XYZOptions\n * @property {import(\"./extent.js\").Extent} [extent] Extent for the tile grid. The origin for an XYZ tile grid is the\n * top-left corner of the extent. The zero level of the grid is defined by the resolution at which one tile fits in the\n * provided extent. If not provided, the extent of the EPSG:3857 projection is used.\n * @property {number} [maxZoom] Maximum zoom. The default is `42`. This determines the number of levels\n * in the grid set. For example, a `maxZoom` of 21 means there are 22 levels in the grid set.\n * @property {number} [minZoom=0] Minimum zoom.\n * @property {number|import(\"./size.js\").Size} [tileSize=[256, 256]] Tile size in pixels.\n */\n\n\n/**\n * Creates a tile grid with a standard XYZ tiling scheme.\n * @param {XYZOptions=} opt_options Tile grid options.\n * @return {!TileGrid} Tile grid instance.\n * @api\n */\nexport function createXYZ(opt_options) {\n  /** @type {XYZOptions} */\n  var xyzOptions = opt_options || {};\n\n  var extent = xyzOptions.extent || getProjection('EPSG:3857').getExtent();\n\n  /** @type {import(\"./tilegrid/TileGrid.js\").Options} */\n  var gridOptions = {\n    extent: extent,\n    minZoom: xyzOptions.minZoom,\n    tileSize: xyzOptions.tileSize,\n    resolutions: resolutionsFromExtent(\n      extent,\n      xyzOptions.maxZoom,\n      xyzOptions.tileSize\n    )\n  };\n  return new TileGrid(gridOptions);\n}\n\n\n/**\n * Create a resolutions array from an extent.  A zoom factor of 2 is assumed.\n * @param {import(\"./extent.js\").Extent} extent Extent.\n * @param {number=} opt_maxZoom Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import(\"./size.js\").Size=} opt_tileSize Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @return {!Array<number>} Resolutions array.\n */\nfunction resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize) {\n  var maxZoom = opt_maxZoom !== undefined ?\n    opt_maxZoom : DEFAULT_MAX_ZOOM;\n\n  var height = getHeight(extent);\n  var width = getWidth(extent);\n\n  var tileSize = toSize(opt_tileSize !== undefined ?\n    opt_tileSize : DEFAULT_TILE_SIZE);\n  var maxResolution = Math.max(\n    width / tileSize[0], height / tileSize[1]);\n\n  var length = maxZoom + 1;\n  var resolutions = new Array(length);\n  for (var z = 0; z < length; ++z) {\n    resolutions[z] = maxResolution / Math.pow(2, z);\n  }\n  return resolutions;\n}\n\n\n/**\n * @param {import(\"./proj.js\").ProjectionLike} projection Projection.\n * @param {number=} opt_maxZoom Maximum zoom level (default is\n *     DEFAULT_MAX_ZOOM).\n * @param {number|import(\"./size.js\").Size=} opt_tileSize Tile size (default uses\n *     DEFAULT_TILE_SIZE).\n * @param {Corner=} opt_corner Extent corner (default is `'top-left'`).\n * @return {!TileGrid} TileGrid instance.\n */\nexport function createForProjection(projection, opt_maxZoom, opt_tileSize, opt_corner) {\n  var extent = extentFromProjection(projection);\n  return createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner);\n}\n\n\n/**\n * Generate a tile grid extent from a projection.  If the projection has an\n * extent, it is used.  If not, a global extent is assumed.\n * @param {import(\"./proj.js\").ProjectionLike} projection Projection.\n * @return {import(\"./extent.js\").Extent} Extent.\n */\nexport function extentFromProjection(projection) {\n  projection = getProjection(projection);\n  var extent = projection.getExtent();\n  if (!extent) {\n    var half = 180 * METERS_PER_UNIT[Units.DEGREES] / projection.getMetersPerUnit();\n    extent = createOrUpdate(-half, -half, half, half);\n  }\n  return extent;\n}\n\n//# sourceMappingURL=tilegrid.js.map","/**\n * @module ol/util\n */\n\n/**\n * @return {?} Any return.\n */\nexport function abstract() {\n  return /** @type {?} */ ((function() {\n    throw new Error('Unimplemented abstract method.');\n  })());\n}\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * Usage:\n *\n *     function ParentClass(a, b) { }\n *     ParentClass.prototype.foo = function(a) { }\n *\n *     function ChildClass(a, b, c) {\n *       // Call parent constructor\n *       ParentClass.call(this, a, b);\n *     }\n *     inherits(ChildClass, ParentClass);\n *\n *     var child = new ChildClass('a', 'b', 'see');\n *     child.foo(); // This works.\n *\n * @param {!Function} childCtor Child constructor.\n * @param {!Function} parentCtor Parent constructor.\n * @function module:ol.inherits\n * @deprecated\n * @api\n */\nexport function inherits(childCtor, parentCtor) {\n  childCtor.prototype = Object.create(parentCtor.prototype);\n  childCtor.prototype.constructor = childCtor;\n}\n\n/**\n * Counter for getUid.\n * @type {number}\n * @private\n */\nvar uidCounter_ = 0;\n\n/**\n * Gets a unique ID for an object. This mutates the object so that further calls\n * with the same object as a parameter returns the same value. Unique IDs are generated\n * as a strictly increasing sequence. Adapted from goog.getUid.\n *\n * @param {Object} obj The object to get the unique ID for.\n * @return {string} The unique ID for the object.\n * @function module:ol.getUid\n * @api\n */\nexport function getUid(obj) {\n  return obj.ol_uid || (obj.ol_uid = String(++uidCounter_));\n}\n\n/**\n * OpenLayers version.\n * @type {string}\n */\nexport var VERSION = '5.3.3';\n\n//# sourceMappingURL=util.js.map","/**\n * @module ol/tilecoord\n */\n\n\n/**\n * An array of three numbers representing the location of a tile in a tile\n * grid. The order is `z`, `x`, and `y`. `z` is the zoom level.\n * @typedef {Array<number>} TileCoord\n * @api\n */\n\n\n/**\n * @param {number} z Z.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {TileCoord=} opt_tileCoord Tile coordinate.\n * @return {TileCoord} Tile coordinate.\n */\nexport function createOrUpdate(z, x, y, opt_tileCoord) {\n  if (opt_tileCoord !== undefined) {\n    opt_tileCoord[0] = z;\n    opt_tileCoord[1] = x;\n    opt_tileCoord[2] = y;\n    return opt_tileCoord;\n  } else {\n    return [z, x, y];\n  }\n}\n\n\n/**\n * @param {number} z Z.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {string} Key.\n */\nexport function getKeyZXY(z, x, y) {\n  return z + '/' + x + '/' + y;\n}\n\n\n/**\n * Get the key for a tile coord.\n * @param {TileCoord} tileCoord The tile coord.\n * @return {string} Key.\n */\nexport function getKey(tileCoord) {\n  return getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);\n}\n\n\n/**\n * Get a tile coord given a key.\n * @param {string} key The tile coord key.\n * @return {TileCoord} The tile coord.\n */\nexport function fromKey(key) {\n  return key.split('/').map(Number);\n}\n\n\n/**\n * @param {TileCoord} tileCoord Tile coord.\n * @return {number} Hash.\n */\nexport function hash(tileCoord) {\n  return (tileCoord[1] << tileCoord[0]) + tileCoord[2];\n}\n\n\n/**\n * @param {TileCoord} tileCoord Tile coord.\n * @return {string} Quad key.\n */\nexport function quadKey(tileCoord) {\n  var z = tileCoord[0];\n  var digits = new Array(z);\n  var mask = 1 << (z - 1);\n  var i, charCode;\n  for (i = 0; i < z; ++i) {\n    // 48 is charCode for 0 - '0'.charCodeAt(0)\n    charCode = 48;\n    if (tileCoord[1] & mask) {\n      charCode += 1;\n    }\n    if (tileCoord[2] & mask) {\n      charCode += 2;\n    }\n    digits[i] = String.fromCharCode(charCode);\n    mask >>= 1;\n  }\n  return digits.join('');\n}\n\n\n/**\n * @param {TileCoord} tileCoord Tile coordinate.\n * @param {!import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n * @return {boolean} Tile coordinate is within extent and zoom level range.\n */\nexport function withinExtentAndZ(tileCoord, tileGrid) {\n  var z = tileCoord[0];\n  var x = tileCoord[1];\n  var y = tileCoord[2];\n\n  if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {\n    return false;\n  }\n  var extent = tileGrid.getExtent();\n  var tileRange;\n  if (!extent) {\n    tileRange = tileGrid.getFullTileRange(z);\n  } else {\n    tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);\n  }\n  if (!tileRange) {\n    return true;\n  } else {\n    return tileRange.containsXY(x, y);\n  }\n}\n\n//# sourceMappingURL=tilecoord.js.map","/**\n * @module ol/tilegrid/TileGrid\n */\nimport {DEFAULT_TILE_SIZE} from './common.js';\nimport {assert} from '../asserts.js';\nimport TileRange, {createOrUpdate as createOrUpdateTileRange} from '../TileRange.js';\nimport {isSorted, linearFindNearest} from '../array.js';\nimport {createOrUpdate, getTopLeft} from '../extent.js';\nimport {clamp} from '../math.js';\nimport {toSize} from '../size.js';\nimport {createOrUpdate as createOrUpdateTileCoord} from '../tilecoord.js';\n\n\n/**\n * @private\n * @type {import(\"../tilecoord.js\").TileCoord}\n */\nvar tmpTileCoord = [0, 0, 0];\n\n\n/**\n * @typedef {Object} Options\n * @property {import(\"../extent.js\").Extent} [extent] Extent for the tile grid. No tiles outside this\n * extent will be requested by {@link module:ol/source/Tile} sources. When no `origin` or\n * `origins` are configured, the `origin` will be set to the top-left corner of the extent.\n * @property {number} [minZoom=0] Minimum zoom.\n * @property {import(\"../coordinate.js\").Coordinate} [origin] The tile grid origin, i.e. where the `x`\n * and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left to right and upwards. If not\n * specified, `extent` or `origins` must be provided.\n * @property {Array<import(\"../coordinate.js\").Coordinate>} [origins] Tile grid origins, i.e. where\n * the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If given, the array length\n * should match the length of the `resolutions` array, i.e. each resolution can have a different\n * origin. Tile coordinates increase left to right and upwards. If not specified, `extent` or\n * `origin` must be provided.\n * @property {!Array<number>} resolutions Resolutions. The array index of each resolution needs\n * to match the zoom level. This means that even if a `minZoom` is configured, the resolutions\n * array will have a length of `maxZoom + 1`.\n * @property {Array<import(\"../size.js\").Size>} [sizes] Sizes.\n * @property {number|import(\"../size.js\").Size} [tileSize] Tile size.\n * Default is `[256, 256]`.\n * @property {Array<import(\"../size.js\").Size>} [tileSizes] Tile sizes. If given, the array length\n * should match the length of the `resolutions` array, i.e. each resolution can have a different\n * tile size.\n */\n\n\n/**\n * @classdesc\n * Base class for setting the grid pattern for sources accessing tiled-image\n * servers.\n * @api\n */\nvar TileGrid = function TileGrid(options) {\n\n  /**\n   * @protected\n   * @type {number}\n   */\n  this.minZoom = options.minZoom !== undefined ? options.minZoom : 0;\n\n  /**\n   * @private\n   * @type {!Array<number>}\n   */\n  this.resolutions_ = options.resolutions;\n  assert(isSorted(this.resolutions_, function(a, b) {\n    return b - a;\n  }, true), 17); // `resolutions` must be sorted in descending order\n\n\n  // check if we've got a consistent zoom factor and origin\n  var zoomFactor;\n  if (!options.origins) {\n    for (var i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {\n      if (!zoomFactor) {\n        zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];\n      } else {\n        if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {\n          zoomFactor = undefined;\n          break;\n        }\n      }\n    }\n  }\n\n\n  /**\n   * @private\n   * @type {number|undefined}\n   */\n  this.zoomFactor_ = zoomFactor;\n\n\n  /**\n   * @protected\n   * @type {number}\n   */\n  this.maxZoom = this.resolutions_.length - 1;\n\n  /**\n   * @private\n   * @type {import(\"../coordinate.js\").Coordinate}\n   */\n  this.origin_ = options.origin !== undefined ? options.origin : null;\n\n  /**\n   * @private\n   * @type {Array<import(\"../coordinate.js\").Coordinate>}\n   */\n  this.origins_ = null;\n  if (options.origins !== undefined) {\n    this.origins_ = options.origins;\n    assert(this.origins_.length == this.resolutions_.length,\n      20); // Number of `origins` and `resolutions` must be equal\n  }\n\n  var extent = options.extent;\n\n  if (extent !== undefined &&\n      !this.origin_ && !this.origins_) {\n    this.origin_ = getTopLeft(extent);\n  }\n\n  assert(\n    (!this.origin_ && this.origins_) || (this.origin_ && !this.origins_),\n    18); // Either `origin` or `origins` must be configured, never both\n\n  /**\n   * @private\n   * @type {Array<number|import(\"../size.js\").Size>}\n   */\n  this.tileSizes_ = null;\n  if (options.tileSizes !== undefined) {\n    this.tileSizes_ = options.tileSizes;\n    assert(this.tileSizes_.length == this.resolutions_.length,\n      19); // Number of `tileSizes` and `resolutions` must be equal\n  }\n\n  /**\n   * @private\n   * @type {number|import(\"../size.js\").Size}\n   */\n  this.tileSize_ = options.tileSize !== undefined ?\n    options.tileSize :\n    !this.tileSizes_ ? DEFAULT_TILE_SIZE : null;\n  assert(\n    (!this.tileSize_ && this.tileSizes_) ||\n      (this.tileSize_ && !this.tileSizes_),\n    22); // Either `tileSize` or `tileSizes` must be configured, never both\n\n  /**\n   * @private\n   * @type {import(\"../extent.js\").Extent}\n   */\n  this.extent_ = extent !== undefined ? extent : null;\n\n\n  /**\n   * @private\n   * @type {Array<import(\"../TileRange.js\").default>}\n   */\n  this.fullTileRanges_ = null;\n\n  /**\n   * @private\n   * @type {import(\"../size.js\").Size}\n   */\n  this.tmpSize_ = [0, 0];\n\n  if (options.sizes !== undefined) {\n    this.fullTileRanges_ = options.sizes.map(function(size, z) {\n      var tileRange = new TileRange(\n        Math.min(0, size[0]), Math.max(size[0] - 1, -1),\n        Math.min(0, size[1]), Math.max(size[1] - 1, -1));\n      return tileRange;\n    }, this);\n  } else if (extent) {\n    this.calculateTileRanges_(extent);\n  }\n\n};\n\n/**\n * Call a function with each tile coordinate for a given extent and zoom level.\n *\n * @param {import(\"../extent.js\").Extent} extent Extent.\n * @param {number} zoom Integer zoom level.\n * @param {function(import(\"../tilecoord.js\").TileCoord)} callback Function called with each tile coordinate.\n * @api\n */\nTileGrid.prototype.forEachTileCoord = function forEachTileCoord (extent, zoom, callback) {\n  var tileRange = this.getTileRangeForExtentAndZ(extent, zoom);\n  for (var i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {\n    for (var j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {\n      callback([zoom, i, j]);\n    }\n  }\n};\n\n/**\n * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n * @param {function(this: T, number, import(\"../TileRange.js\").default): boolean} callback Callback.\n * @param {T=} opt_this The object to use as `this` in `callback`.\n * @param {import(\"../TileRange.js\").default=} opt_tileRange Temporary import(\"../TileRange.js\").default object.\n * @param {import(\"../extent.js\").Extent=} opt_extent Temporary import(\"../extent.js\").Extent object.\n * @return {boolean} Callback succeeded.\n * @template T\n */\nTileGrid.prototype.forEachTileCoordParentTileRange = function forEachTileCoordParentTileRange (tileCoord, callback, opt_this, opt_tileRange, opt_extent) {\n  var tileRange, x, y;\n  var tileCoordExtent = null;\n  var z = tileCoord[0] - 1;\n  if (this.zoomFactor_ === 2) {\n    x = tileCoord[1];\n    y = tileCoord[2];\n  } else {\n    tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);\n  }\n  while (z >= this.minZoom) {\n    if (this.zoomFactor_ === 2) {\n      x = Math.floor(x / 2);\n      y = Math.floor(y / 2);\n      tileRange = createOrUpdateTileRange(x, x, y, y, opt_tileRange);\n    } else {\n      tileRange = this.getTileRangeForExtentAndZ(tileCoordExtent, z, opt_tileRange);\n    }\n    if (callback.call(opt_this, z, tileRange)) {\n      return true;\n    }\n    --z;\n  }\n  return false;\n};\n\n/**\n * Get the extent for this tile grid, if it was configured.\n * @return {import(\"../extent.js\").Extent} Extent.\n */\nTileGrid.prototype.getExtent = function getExtent () {\n  return this.extent_;\n};\n\n/**\n * Get the maximum zoom level for the grid.\n * @return {number} Max zoom.\n * @api\n */\nTileGrid.prototype.getMaxZoom = function getMaxZoom () {\n  return this.maxZoom;\n};\n\n/**\n * Get the minimum zoom level for the grid.\n * @return {number} Min zoom.\n * @api\n */\nTileGrid.prototype.getMinZoom = function getMinZoom () {\n  return this.minZoom;\n};\n\n/**\n * Get the origin for the grid at the given zoom level.\n * @param {number} z Integer zoom level.\n * @return {import(\"../coordinate.js\").Coordinate} Origin.\n * @api\n */\nTileGrid.prototype.getOrigin = function getOrigin (z) {\n  if (this.origin_) {\n    return this.origin_;\n  } else {\n    return this.origins_[z];\n  }\n};\n\n/**\n * Get the resolution for the given zoom level.\n * @param {number} z Integer zoom level.\n * @return {number} Resolution.\n * @api\n */\nTileGrid.prototype.getResolution = function getResolution (z) {\n  return this.resolutions_[z];\n};\n\n/**\n * Get the list of resolutions for the tile grid.\n * @return {Array<number>} Resolutions.\n * @api\n */\nTileGrid.prototype.getResolutions = function getResolutions () {\n  return this.resolutions_;\n};\n\n/**\n * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n * @param {import(\"../TileRange.js\").default=} opt_tileRange Temporary import(\"../TileRange.js\").default object.\n * @param {import(\"../extent.js\").Extent=} opt_extent Temporary import(\"../extent.js\").Extent object.\n * @return {import(\"../TileRange.js\").default} Tile range.\n */\nTileGrid.prototype.getTileCoordChildTileRange = function getTileCoordChildTileRange (tileCoord, opt_tileRange, opt_extent) {\n  if (tileCoord[0] < this.maxZoom) {\n    if (this.zoomFactor_ === 2) {\n      var minX = tileCoord[1] * 2;\n      var minY = tileCoord[2] * 2;\n      return createOrUpdateTileRange(minX, minX + 1, minY, minY + 1, opt_tileRange);\n    }\n    var tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);\n    return this.getTileRangeForExtentAndZ(\n      tileCoordExtent, tileCoord[0] + 1, opt_tileRange);\n  }\n  return null;\n};\n\n/**\n * Get the extent for a tile range.\n * @param {number} z Integer zoom level.\n * @param {import(\"../TileRange.js\").default} tileRange Tile range.\n * @param {import(\"../extent.js\").Extent=} opt_extent Temporary import(\"../extent.js\").Extent object.\n * @return {import(\"../extent.js\").Extent} Extent.\n */\nTileGrid.prototype.getTileRangeExtent = function getTileRangeExtent (z, tileRange, opt_extent) {\n  var origin = this.getOrigin(z);\n  var resolution = this.getResolution(z);\n  var tileSize = toSize(this.getTileSize(z), this.tmpSize_);\n  var minX = origin[0] + tileRange.minX * tileSize[0] * resolution;\n  var maxX = origin[0] + (tileRange.maxX + 1) * tileSize[0] * resolution;\n  var minY = origin[1] + tileRange.minY * tileSize[1] * resolution;\n  var maxY = origin[1] + (tileRange.maxY + 1) * tileSize[1] * resolution;\n  return createOrUpdate(minX, minY, maxX, maxY, opt_extent);\n};\n\n/**\n * Get a tile range for the given extent and integer zoom level.\n * @param {import(\"../extent.js\").Extent} extent Extent.\n * @param {number} z Integer zoom level.\n * @param {import(\"../TileRange.js\").default=} opt_tileRange Temporary tile range object.\n * @return {import(\"../TileRange.js\").default} Tile range.\n */\nTileGrid.prototype.getTileRangeForExtentAndZ = function getTileRangeForExtentAndZ (extent, z, opt_tileRange) {\n  var tileCoord = tmpTileCoord;\n  this.getTileCoordForXYAndZ_(extent[0], extent[1], z, false, tileCoord);\n  var minX = tileCoord[1];\n  var minY = tileCoord[2];\n  this.getTileCoordForXYAndZ_(extent[2], extent[3], z, true, tileCoord);\n  return createOrUpdateTileRange(minX, tileCoord[1], minY, tileCoord[2], opt_tileRange);\n};\n\n/**\n * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n * @return {import(\"../coordinate.js\").Coordinate} Tile center.\n */\nTileGrid.prototype.getTileCoordCenter = function getTileCoordCenter (tileCoord) {\n  var origin = this.getOrigin(tileCoord[0]);\n  var resolution = this.getResolution(tileCoord[0]);\n  var tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);\n  return [\n    origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution,\n    origin[1] + (tileCoord[2] + 0.5) * tileSize[1] * resolution\n  ];\n};\n\n/**\n * Get the extent of a tile coordinate.\n *\n * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n * @param {import(\"../extent.js\").Extent=} opt_extent Temporary extent object.\n * @return {import(\"../extent.js\").Extent} Extent.\n * @api\n */\nTileGrid.prototype.getTileCoordExtent = function getTileCoordExtent (tileCoord, opt_extent) {\n  var origin = this.getOrigin(tileCoord[0]);\n  var resolution = this.getResolution(tileCoord[0]);\n  var tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);\n  var minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;\n  var minY = origin[1] + tileCoord[2] * tileSize[1] * resolution;\n  var maxX = minX + tileSize[0] * resolution;\n  var maxY = minY + tileSize[1] * resolution;\n  return createOrUpdate(minX, minY, maxX, maxY, opt_extent);\n};\n\n/**\n * Get the tile coordinate for the given map coordinate and resolution.This\n * method considers that coordinates that intersect tile boundaries should be\n * assigned the higher tile coordinate.\n *\n * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n * @param {number} resolution Resolution.\n * @param {import(\"../tilecoord.js\").TileCoord=} opt_tileCoord Destination import(\"../tilecoord.js\").TileCoord object.\n * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n * @api\n */\nTileGrid.prototype.getTileCoordForCoordAndResolution = function getTileCoordForCoordAndResolution (coordinate, resolution, opt_tileCoord) {\n  return this.getTileCoordForXYAndResolution_(\n    coordinate[0], coordinate[1], resolution, false, opt_tileCoord);\n};\n\n/**\n * Note that this method should not be called for resolutions that correspond\n * to an integer zoom level.Instead call the `getTileCoordForXYAndZ_` method.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {number} resolution Resolution (for a non-integer zoom level).\n * @param {boolean} reverseIntersectionPolicy Instead of letting edge\n *   intersections go to the higher tile coordinate, let edge intersections\n *   go to the lower tile coordinate.\n * @param {import(\"../tilecoord.js\").TileCoord=} opt_tileCoord Temporary import(\"../tilecoord.js\").TileCoord object.\n * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n * @private\n */\nTileGrid.prototype.getTileCoordForXYAndResolution_ = function getTileCoordForXYAndResolution_ (x, y, resolution, reverseIntersectionPolicy, opt_tileCoord) {\n  var z = this.getZForResolution(resolution);\n  var scale = resolution / this.getResolution(z);\n  var origin = this.getOrigin(z);\n  var tileSize = toSize(this.getTileSize(z), this.tmpSize_);\n\n  var adjustX = reverseIntersectionPolicy ? 0.5 : 0;\n  var adjustY = reverseIntersectionPolicy ? 0 : 0.5;\n  var xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);\n  var yFromOrigin = Math.floor((y - origin[1]) / resolution + adjustY);\n  var tileCoordX = scale * xFromOrigin / tileSize[0];\n  var tileCoordY = scale * yFromOrigin / tileSize[1];\n\n  if (reverseIntersectionPolicy) {\n    tileCoordX = Math.ceil(tileCoordX) - 1;\n    tileCoordY = Math.ceil(tileCoordY) - 1;\n  } else {\n    tileCoordX = Math.floor(tileCoordX);\n    tileCoordY = Math.floor(tileCoordY);\n  }\n\n  return createOrUpdateTileCoord(z, tileCoordX, tileCoordY, opt_tileCoord);\n};\n\n/**\n * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,\n * they should have separate implementations.This method is for integer zoom\n * levels.The other method should only be called for resolutions corresponding\n * to non-integer zoom levels.\n * @param {number} x Map x coordinate.\n * @param {number} y Map y coordinate.\n * @param {number} z Integer zoom level.\n * @param {boolean} reverseIntersectionPolicy Instead of letting edge\n *   intersections go to the higher tile coordinate, let edge intersections\n *   go to the lower tile coordinate.\n * @param {import(\"../tilecoord.js\").TileCoord=} opt_tileCoord Temporary import(\"../tilecoord.js\").TileCoord object.\n * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n * @private\n */\nTileGrid.prototype.getTileCoordForXYAndZ_ = function getTileCoordForXYAndZ_ (x, y, z, reverseIntersectionPolicy, opt_tileCoord) {\n  var origin = this.getOrigin(z);\n  var resolution = this.getResolution(z);\n  var tileSize = toSize(this.getTileSize(z), this.tmpSize_);\n\n  var adjustX = reverseIntersectionPolicy ? 0.5 : 0;\n  var adjustY = reverseIntersectionPolicy ? 0 : 0.5;\n  var xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);\n  var yFromOrigin = Math.floor((y - origin[1]) / resolution + adjustY);\n  var tileCoordX = xFromOrigin / tileSize[0];\n  var tileCoordY = yFromOrigin / tileSize[1];\n\n  if (reverseIntersectionPolicy) {\n    tileCoordX = Math.ceil(tileCoordX) - 1;\n    tileCoordY = Math.ceil(tileCoordY) - 1;\n  } else {\n    tileCoordX = Math.floor(tileCoordX);\n    tileCoordY = Math.floor(tileCoordY);\n  }\n\n  return createOrUpdateTileCoord(z, tileCoordX, tileCoordY, opt_tileCoord);\n};\n\n/**\n * Get a tile coordinate given a map coordinate and zoom level.\n * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n * @param {number} z Zoom level.\n * @param {import(\"../tilecoord.js\").TileCoord=} opt_tileCoord Destination import(\"../tilecoord.js\").TileCoord object.\n * @return {import(\"../tilecoord.js\").TileCoord} Tile coordinate.\n * @api\n */\nTileGrid.prototype.getTileCoordForCoordAndZ = function getTileCoordForCoordAndZ (coordinate, z, opt_tileCoord) {\n  return this.getTileCoordForXYAndZ_(\n    coordinate[0], coordinate[1], z, false, opt_tileCoord);\n};\n\n/**\n * @param {import(\"../tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n * @return {number} Tile resolution.\n */\nTileGrid.prototype.getTileCoordResolution = function getTileCoordResolution (tileCoord) {\n  return this.resolutions_[tileCoord[0]];\n};\n\n/**\n * Get the tile size for a zoom level. The type of the return value matches the\n * `tileSize` or `tileSizes` that the tile grid was configured with. To always\n * get an `import(\"../size.js\").Size`, run the result through `import(\"../size.js\").Size.toSize()`.\n * @param {number} z Z.\n * @return {number|import(\"../size.js\").Size} Tile size.\n * @api\n */\nTileGrid.prototype.getTileSize = function getTileSize (z) {\n  if (this.tileSize_) {\n    return this.tileSize_;\n  } else {\n    return this.tileSizes_[z];\n  }\n};\n\n/**\n * @param {number} z Zoom level.\n * @return {import(\"../TileRange.js\").default} Extent tile range for the specified zoom level.\n */\nTileGrid.prototype.getFullTileRange = function getFullTileRange (z) {\n  if (!this.fullTileRanges_) {\n    return null;\n  } else {\n    return this.fullTileRanges_[z];\n  }\n};\n\n/**\n * @param {number} resolution Resolution.\n * @param {number=} opt_direction If 0, the nearest resolution will be used.\n *   If 1, the nearest lower resolution will be used. If -1, the nearest\n *   higher resolution will be used. Default is 0.\n * @return {number} Z.\n * @api\n */\nTileGrid.prototype.getZForResolution = function getZForResolution (resolution, opt_direction) {\n  var z = linearFindNearest(this.resolutions_, resolution, opt_direction || 0);\n  return clamp(z, this.minZoom, this.maxZoom);\n};\n\n/**\n * @param {!import(\"../extent.js\").Extent} extent Extent for this tile grid.\n * @private\n */\nTileGrid.prototype.calculateTileRanges_ = function calculateTileRanges_ (extent) {\n  var length = this.resolutions_.length;\n  var fullTileRanges = new Array(length);\n  for (var z = this.minZoom; z < length; ++z) {\n    fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);\n  }\n  this.fullTileRanges_ = fullTileRanges;\n};\n\n\nexport default TileGrid;\n\n//# sourceMappingURL=TileGrid.js.map","/**\n * @module ol/tileurlfunction\n */\nimport {assert} from './asserts.js';\nimport {modulo} from './math.js';\nimport {hash as tileCoordHash} from './tilecoord.js';\n\n\n/**\n * @param {string} template Template.\n * @param {import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n * @return {import(\"./Tile.js\").UrlFunction} Tile URL function.\n */\nexport function createFromTemplate(template, tileGrid) {\n  var zRegEx = /\\{z\\}/g;\n  var xRegEx = /\\{x\\}/g;\n  var yRegEx = /\\{y\\}/g;\n  var dashYRegEx = /\\{-y\\}/g;\n  return (\n    /**\n     * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile Coordinate.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"./proj/Projection.js\").default} projection Projection.\n     * @return {string|undefined} Tile URL.\n     */\n    function(tileCoord, pixelRatio, projection) {\n      if (!tileCoord) {\n        return undefined;\n      } else {\n        return template.replace(zRegEx, tileCoord[0].toString())\n          .replace(xRegEx, tileCoord[1].toString())\n          .replace(yRegEx, function() {\n            var y = -tileCoord[2] - 1;\n            return y.toString();\n          })\n          .replace(dashYRegEx, function() {\n            var z = tileCoord[0];\n            var range = tileGrid.getFullTileRange(z);\n            assert(range, 55); // The {-y} placeholder requires a tile grid with extent\n            var y = range.getHeight() + tileCoord[2];\n            return y.toString();\n          });\n      }\n    }\n  );\n}\n\n\n/**\n * @param {Array<string>} templates Templates.\n * @param {import(\"./tilegrid/TileGrid.js\").default} tileGrid Tile grid.\n * @return {import(\"./Tile.js\").UrlFunction} Tile URL function.\n */\nexport function createFromTemplates(templates, tileGrid) {\n  var len = templates.length;\n  var tileUrlFunctions = new Array(len);\n  for (var i = 0; i < len; ++i) {\n    tileUrlFunctions[i] = createFromTemplate(templates[i], tileGrid);\n  }\n  return createFromTileUrlFunctions(tileUrlFunctions);\n}\n\n\n/**\n * @param {Array<import(\"./Tile.js\").UrlFunction>} tileUrlFunctions Tile URL Functions.\n * @return {import(\"./Tile.js\").UrlFunction} Tile URL function.\n */\nexport function createFromTileUrlFunctions(tileUrlFunctions) {\n  if (tileUrlFunctions.length === 1) {\n    return tileUrlFunctions[0];\n  }\n  return (\n    /**\n     * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile Coordinate.\n     * @param {number} pixelRatio Pixel ratio.\n     * @param {import(\"./proj/Projection.js\").default} projection Projection.\n     * @return {string|undefined} Tile URL.\n     */\n    function(tileCoord, pixelRatio, projection) {\n      if (!tileCoord) {\n        return undefined;\n      } else {\n        var h = tileCoordHash(tileCoord);\n        var index = modulo(h, tileUrlFunctions.length);\n        return tileUrlFunctions[index](tileCoord, pixelRatio, projection);\n      }\n    }\n  );\n}\n\n\n/**\n * @param {import(\"./tilecoord.js\").TileCoord} tileCoord Tile coordinate.\n * @param {number} pixelRatio Pixel ratio.\n * @param {import(\"./proj/Projection.js\").default} projection Projection.\n * @return {string|undefined} Tile URL.\n */\nexport function nullTileUrlFunction(tileCoord, pixelRatio, projection) {\n  return undefined;\n}\n\n\n/**\n * @param {string} url URL.\n * @return {Array<string>} Array of urls.\n */\nexport function expandUrl(url) {\n  var urls = [];\n  var match = /\\{([a-z])-([a-z])\\}/.exec(url);\n  if (match) {\n    // char range\n    var startCharCode = match[1].charCodeAt(0);\n    var stopCharCode = match[2].charCodeAt(0);\n    var charCode;\n    for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {\n      urls.push(url.replace(match[0], String.fromCharCode(charCode)));\n    }\n    return urls;\n  }\n  match = match = /\\{(\\d+)-(\\d+)\\}/.exec(url);\n  if (match) {\n    // number range\n    var stop = parseInt(match[2], 10);\n    for (var i = parseInt(match[1], 10); i <= stop; i++) {\n      urls.push(url.replace(match[0], i.toString()));\n    }\n    return urls;\n  }\n  urls.push(url);\n  return urls;\n}\n\n//# sourceMappingURL=tileurlfunction.js.map","/**\n * @module ol/transform\n */\nimport {assert} from './asserts.js';\n\n\n/**\n * An array representing an affine 2d transformation for use with\n * {@link module:ol/transform} functions. The array has 6 elements.\n * @typedef {!Array<number>} Transform\n */\n\n\n/**\n * Collection of affine 2d transformation functions. The functions work on an\n * array of 6 elements. The element order is compatible with the [SVGMatrix\n * interface](https://developer.mozilla.org/en-US/docs/Web/API/SVGMatrix) and is\n * a subset (elements a to f) of a 3×3 matrix:\n * ```\n * [ a c e ]\n * [ b d f ]\n * [ 0 0 1 ]\n * ```\n */\n\n\n/**\n * @private\n * @type {Transform}\n */\nvar tmp_ = new Array(6);\n\n\n/**\n * Create an identity transform.\n * @return {!Transform} Identity transform.\n */\nexport function create() {\n  return [1, 0, 0, 1, 0, 0];\n}\n\n\n/**\n * Resets the given transform to an identity transform.\n * @param {!Transform} transform Transform.\n * @return {!Transform} Transform.\n */\nexport function reset(transform) {\n  return set(transform, 1, 0, 0, 1, 0, 0);\n}\n\n\n/**\n * Multiply the underlying matrices of two transforms and return the result in\n * the first transform.\n * @param {!Transform} transform1 Transform parameters of matrix 1.\n * @param {!Transform} transform2 Transform parameters of matrix 2.\n * @return {!Transform} transform1 multiplied with transform2.\n */\nexport function multiply(transform1, transform2) {\n  var a1 = transform1[0];\n  var b1 = transform1[1];\n  var c1 = transform1[2];\n  var d1 = transform1[3];\n  var e1 = transform1[4];\n  var f1 = transform1[5];\n  var a2 = transform2[0];\n  var b2 = transform2[1];\n  var c2 = transform2[2];\n  var d2 = transform2[3];\n  var e2 = transform2[4];\n  var f2 = transform2[5];\n\n  transform1[0] = a1 * a2 + c1 * b2;\n  transform1[1] = b1 * a2 + d1 * b2;\n  transform1[2] = a1 * c2 + c1 * d2;\n  transform1[3] = b1 * c2 + d1 * d2;\n  transform1[4] = a1 * e2 + c1 * f2 + e1;\n  transform1[5] = b1 * e2 + d1 * f2 + f1;\n\n  return transform1;\n}\n\n/**\n * Set the transform components a-f on a given transform.\n * @param {!Transform} transform Transform.\n * @param {number} a The a component of the transform.\n * @param {number} b The b component of the transform.\n * @param {number} c The c component of the transform.\n * @param {number} d The d component of the transform.\n * @param {number} e The e component of the transform.\n * @param {number} f The f component of the transform.\n * @return {!Transform} Matrix with transform applied.\n */\nexport function set(transform, a, b, c, d, e, f) {\n  transform[0] = a;\n  transform[1] = b;\n  transform[2] = c;\n  transform[3] = d;\n  transform[4] = e;\n  transform[5] = f;\n  return transform;\n}\n\n\n/**\n * Set transform on one matrix from another matrix.\n * @param {!Transform} transform1 Matrix to set transform to.\n * @param {!Transform} transform2 Matrix to set transform from.\n * @return {!Transform} transform1 with transform from transform2 applied.\n */\nexport function setFromArray(transform1, transform2) {\n  transform1[0] = transform2[0];\n  transform1[1] = transform2[1];\n  transform1[2] = transform2[2];\n  transform1[3] = transform2[3];\n  transform1[4] = transform2[4];\n  transform1[5] = transform2[5];\n  return transform1;\n}\n\n\n/**\n * Transforms the given coordinate with the given transform returning the\n * resulting, transformed coordinate. The coordinate will be modified in-place.\n *\n * @param {Transform} transform The transformation.\n * @param {import(\"./coordinate.js\").Coordinate|import(\"./pixel.js\").Pixel} coordinate The coordinate to transform.\n * @return {import(\"./coordinate.js\").Coordinate|import(\"./pixel.js\").Pixel} return coordinate so that operations can be\n *     chained together.\n */\nexport function apply(transform, coordinate) {\n  var x = coordinate[0];\n  var y = coordinate[1];\n  coordinate[0] = transform[0] * x + transform[2] * y + transform[4];\n  coordinate[1] = transform[1] * x + transform[3] * y + transform[5];\n  return coordinate;\n}\n\n\n/**\n * Applies rotation to the given transform.\n * @param {!Transform} transform Transform.\n * @param {number} angle Angle in radians.\n * @return {!Transform} The rotated transform.\n */\nexport function rotate(transform, angle) {\n  var cos = Math.cos(angle);\n  var sin = Math.sin(angle);\n  return multiply(transform, set(tmp_, cos, sin, -sin, cos, 0, 0));\n}\n\n\n/**\n * Applies scale to a given transform.\n * @param {!Transform} transform Transform.\n * @param {number} x Scale factor x.\n * @param {number} y Scale factor y.\n * @return {!Transform} The scaled transform.\n */\nexport function scale(transform, x, y) {\n  return multiply(transform, set(tmp_, x, 0, 0, y, 0, 0));\n}\n\n\n/**\n * Applies translation to the given transform.\n * @param {!Transform} transform Transform.\n * @param {number} dx Translation x.\n * @param {number} dy Translation y.\n * @return {!Transform} The translated transform.\n */\nexport function translate(transform, dx, dy) {\n  return multiply(transform, set(tmp_, 1, 0, 0, 1, dx, dy));\n}\n\n\n/**\n * Creates a composite transform given an initial translation, scale, rotation, and\n * final translation (in that order only, not commutative).\n * @param {!Transform} transform The transform (will be modified in place).\n * @param {number} dx1 Initial translation x.\n * @param {number} dy1 Initial translation y.\n * @param {number} sx Scale factor x.\n * @param {number} sy Scale factor y.\n * @param {number} angle Rotation (in counter-clockwise radians).\n * @param {number} dx2 Final translation x.\n * @param {number} dy2 Final translation y.\n * @return {!Transform} The composite transform.\n */\nexport function compose(transform, dx1, dy1, sx, sy, angle, dx2, dy2) {\n  var sin = Math.sin(angle);\n  var cos = Math.cos(angle);\n  transform[0] = sx * cos;\n  transform[1] = sy * sin;\n  transform[2] = -sx * sin;\n  transform[3] = sy * cos;\n  transform[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;\n  transform[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;\n  return transform;\n}\n\n\n/**\n * Invert the given transform.\n * @param {!Transform} transform Transform.\n * @return {!Transform} Inverse of the transform.\n */\nexport function invert(transform) {\n  var det = determinant(transform);\n  assert(det !== 0, 32); // Transformation matrix cannot be inverted\n\n  var a = transform[0];\n  var b = transform[1];\n  var c = transform[2];\n  var d = transform[3];\n  var e = transform[4];\n  var f = transform[5];\n\n  transform[0] = d / det;\n  transform[1] = -b / det;\n  transform[2] = -c / det;\n  transform[3] = a / det;\n  transform[4] = (c * f - d * e) / det;\n  transform[5] = -(a * f - b * e) / det;\n\n  return transform;\n}\n\n\n/**\n * Returns the determinant of the given matrix.\n * @param {!Transform} mat Matrix.\n * @return {number} Determinant.\n */\nexport function determinant(mat) {\n  return mat[0] * mat[3] - mat[1] * mat[2];\n}\n\n//# sourceMappingURL=transform.js.map"],"sourceRoot":""}