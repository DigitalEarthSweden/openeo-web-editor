{"version":3,"sources":["webpack:///./node_modules/ol/geom/flat/textpath.js","webpack:///./node_modules/ol/geom/LinearRing.js","webpack:///./node_modules/ol/geom/flat/interiorpoint.js","webpack:///./node_modules/ol/geom/flat/simplify.js","webpack:///./node_modules/ol/geom/flat/contains.js","webpack:///./node_modules/ol/geom/MultiLineString.js","webpack:///./node_modules/ol/geom/flat/reverse.js","webpack:///./node_modules/ol/geom/flat/orient.js","webpack:///./node_modules/ol/geom/GeometryLayout.js","webpack:///./node_modules/ol/functions.js","webpack:///./node_modules/ol/geom/flat/length.js","webpack:///./node_modules/ol/geom/Polygon.js","webpack:///./node_modules/ol/geom/LineString.js","webpack:///./node_modules/ol/geom/flat/straightchunk.js","webpack:///./node_modules/ol/geom/flat/center.js","webpack:///./node_modules/ol/geom/MultiPolygon.js","webpack:///./node_modules/ol/geom/Geometry.js","webpack:///./node_modules/ol/geom/flat/closest.js","webpack:///./node_modules/ol/geom/MultiPoint.js","webpack:///./node_modules/ol/geom/SimpleGeometry.js","webpack:///./node_modules/ol/geom/flat/deflate.js","webpack:///./node_modules/ol/geom/flat/interpolate.js","webpack:///./node_modules/ol/geom/flat/area.js","webpack:///./node_modules/ol/geom/flat/inflate.js","webpack:///./node_modules/ol/geom/flat/transform.js","webpack:///./node_modules/ol/geom/flat/intersectsextent.js","webpack:///./node_modules/ol/geom/GeometryCollection.js","webpack:///./node_modules/ol/geom/Point.js","webpack:///./node_modules/ol/geom/GeometryType.js","webpack:///./node_modules/ol/geom/Circle.js","webpack:///./node_modules/ol/geom/flat/segments.js"],"names":["drawTextOnPath","flatCoordinates","offset","end","stride","text","measure","startM","maxAngle","result","reverse","numChars","length","x1","y1","data","index","previousAngle","x2","y2","segmentM","segmentLength","Math","sqrt","pow","chunk","chunkLength","i","char","charAt","charLength","charM","segmentPos","angle","atan2","PI","undefined","delta","abs","interpolate","x","y","unshift","push","LinearRing","SimpleGeometry","coordinates","opt_layout","call","this","maxDelta_","maxDeltaRevision_","Array","isArray","setCoordinates","setFlatCoordinates","__proto__","prototype","Object","create","constructor","clone","slice","layout","closestPointXY","closestPoint","minSquaredDistance","getExtent","getRevision","getArea","getCoordinates","getSimplifiedGeometryInternal","squaredTolerance","simplifiedFlatCoordinates","XY","getType","LINEAR_RING","intersectsExtent","extent","setLayout","changed","getInteriorPointOfArray","ends","flatCenters","flatCentersOffset","opt_dest","ii","intersections","r","rr","pointX","NaN","maxSegmentLength","Infinity","sort","isNaN","getInteriorPointsOfMultiArray","endss","interiorPoints","douglasPeucker","simplifiedOffset","n","markers","stack","last","pop","first","maxSquaredDistance","squaredDistance","i$1","douglasPeuckerArray","simplifiedEnds","snap","value","tolerance","round","quantize","x3","y3","dx1","dy1","dx2","dy2","quantizeArray","quantizeMultiArray","simplifiedEndss","linearRingContainsExtent","outside","coordinate","linearRingContainsXY","wn","linearRingsContainsXY","linearRingssContainsXY","MultiLineString","opt_ends","ends_","getLayout","lineStrings","lineString","getFlatCoordinates","appendLineString","getCoordinateAtM","m","opt_extrapolate","opt_interpolate","XYM","XYZM","extrapolate","getEnds","getLineString","getLineStrings","getFlatMidpoints","midpoints","midpoint","MULTI_LINE_STRING","tmp","linearRingIsClockwise","edge","linearRingIsOriented","opt_right","right","isClockwise","linearRingsAreOriented","orientLinearRings","orientLinearRingsArray","XYZ","TRUE","FALSE","VOID","lineStringLength","Polygon","flatInteriorPointRevision_","flatInteriorPoint_","orientedRevision_","orientedFlatCoordinates_","appendLinearRing","linearRing","containsXY","getOrientedFlatCoordinates","getFlatInteriorPoint","flatCenter","getInteriorPoint","getLinearRingCount","getLinearRing","getLinearRings","linearRings","POLYGON","fromExtent","minX","minY","maxX","maxY","fromCircle","circle","opt_sides","opt_angle","sides","getStride","center","getCenter","arrayLength","j","polygon","makeRegular","getRadius","radius","startAngle","cos","sin","LineString","flatMidpoint_","flatMidpointRevision_","appendCoordinate","forEachSegment","callback","getCoordinateAt","fraction","getLength","getFlatMidpoint","LINE_STRING","matchingChunk","acos","m12","m23","x12","y12","x23","y23","chunkStart","chunkEnd","chunkM","start","linearRingss","MultiPolygon","opt_endss","endss_","flatInteriorPointsRevision_","flatInteriorPoints_","polygons","jj","appendPolygon","len","newEndss","orient","inflate","getEndss","getFlatInteriorPoints","getInteriorPoints","MultiPoint","GeometryLayout","getPolygon","prevEnds","getPolygons","GeometryType","MULTI_POLYGON","deflate","lastEnds","tmpTransform","Geometry","BaseObject","extent_","extentRevision_","simplifiedGeometryCache","simplifiedGeometryMaxMinSquaredTolerance","simplifiedGeometryRevision","getClosestPoint","point","opt_closestPoint","intersectsCoordinate","computeExtent","opt_extent","rotate","anchor","scale","sx","opt_sy","opt_anchor","simplify","getSimplifiedGeometry","applyTransform","transformFn","translate","deltaX","deltaY","transform","source","destination","sourceProj","getUnits","TILE_PIXELS","inCoordinates","outCoordinates","pixelExtent","projectedExtent","getWorldExtent","assignClosest","offset1","offset2","dx","dy","t","maxSquaredDelta","max","squaredDelta","arrayMaxSquaredDelta","multiArrayMaxSquaredDelta","assignClosestPoint","maxDelta","isRing","opt_tmpPoint","tmpPoint","assignClosestArrayPoint","assignClosestMultiArrayPoint","appendPoint","multiPoint","getPoint","getPoints","points","MULTI_POINT","getFirstCoordinate","getLastCoordinate","key","toString","hasOwnProperty","simplifiedGeometry","getStrideForLayout","nesting","getLayoutForStride","sy","transformGeom2D","simpleGeometry","deflateCoordinate","deflateCoordinates","deflateCoordinatesArray","coordinatess","deflateMultiCoordinatesArray","coordinatesss","interpolatePoint","pointY","cumulativeLengths","target","o","lineStringCoordinateAtM","lo","hi","mid","m0","m1","lineStringsCoordinateAtM","twiceArea","area","inflateCoordinates","opt_coordinates","inflateCoordinatesArray","opt_coordinatess","inflateMultiCoordinatesArray","opt_coordinatesss","transform2D","dest","anchorX","anchorY","k","intersectsLineString","coordinatesExtent","point1","point2","intersectsLineStringArray","intersectsLinearRing","intersectsLinearRingArray","intersectsLinearRingMultiArray","GeometryCollection","opt_geometries","geometries_","listenGeometriesChange_","unlistenGeometriesChange_","CHANGE","geometryCollection","setGeometries","geometries","getGeometries","cloneGeometries","getGeometriesArray","simplifiedGeometries","simplified","geometry","simplifiedGeometryCollection","setGeometriesArray","GEOMETRY_COLLECTION","isEmpty","disposeInternal","clonedGeometries","Point","POINT","CIRCLE","Circle","opt_radius","setCenterAndRadius","getRadiusSquared_","circleExtent","setCenter","setRadius","forEach","opt_this","ret"],"mappings":"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","file":"js/chunk-7c914176.07d769a5.js","sourcesContent":["/**\n * @module ol/geom/flat/textpath\n */\nimport {lerp} from '../../math.js';\n\n\n/**\n * @param {Array<number>} flatCoordinates Path to put text on.\n * @param {number} offset Start offset of the `flatCoordinates`.\n * @param {number} end End offset of the `flatCoordinates`.\n * @param {number} stride Stride.\n * @param {string} text Text to place on the path.\n * @param {function(string):number} measure Measure function returning the\n * width of the character passed as 1st argument.\n * @param {number} startM m along the path where the text starts.\n * @param {number} maxAngle Max angle between adjacent chars in radians.\n * @return {Array<Array<*>>} The result array of null if `maxAngle` was\n * exceeded. Entries of the array are x, y, anchorX, angle, chunk.\n */\nexport function drawTextOnPath(\n  flatCoordinates, offset, end, stride, text, measure, startM, maxAngle) {\n  var result = [];\n\n  // Keep text upright\n  var reverse = flatCoordinates[offset] > flatCoordinates[end - stride];\n\n  var numChars = text.length;\n\n  var x1 = flatCoordinates[offset];\n  var y1 = flatCoordinates[offset + 1];\n  offset += stride;\n  var x2 = flatCoordinates[offset];\n  var y2 = flatCoordinates[offset + 1];\n  var segmentM = 0;\n  var segmentLength = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n\n  var chunk = '';\n  var chunkLength = 0;\n  var data, index, previousAngle;\n  for (var i = 0; i < numChars; ++i) {\n    index = reverse ? numChars - i - 1 : i;\n    var char = text.charAt(index);\n    chunk = reverse ? char + chunk : chunk + char;\n    var charLength = measure(chunk) - chunkLength;\n    chunkLength += charLength;\n    var charM = startM + charLength / 2;\n    while (offset < end - stride && segmentM + segmentLength < charM) {\n      x1 = x2;\n      y1 = y2;\n      offset += stride;\n      x2 = flatCoordinates[offset];\n      y2 = flatCoordinates[offset + 1];\n      segmentM += segmentLength;\n      segmentLength = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));\n    }\n    var segmentPos = charM - segmentM;\n    var angle = Math.atan2(y2 - y1, x2 - x1);\n    if (reverse) {\n      angle += angle > 0 ? -Math.PI : Math.PI;\n    }\n    if (previousAngle !== undefined) {\n      var delta = angle - previousAngle;\n      delta += (delta > Math.PI) ? -2 * Math.PI : (delta < -Math.PI) ? 2 * Math.PI : 0;\n      if (Math.abs(delta) > maxAngle) {\n        return null;\n      }\n    }\n    var interpolate = segmentPos / segmentLength;\n    var x = lerp(x1, x2, interpolate);\n    var y = lerp(y1, y2, interpolate);\n    if (previousAngle == angle) {\n      if (reverse) {\n        data[0] = x;\n        data[1] = y;\n        data[2] = charLength / 2;\n      }\n      data[4] = chunk;\n    } else {\n      chunk = char;\n      chunkLength = charLength;\n      data = [x, y, charLength / 2, angle, chunk];\n      if (reverse) {\n        result.unshift(data);\n      } else {\n        result.push(data);\n      }\n      previousAngle = angle;\n    }\n    startM += charLength;\n  }\n  return result;\n}\n\n//# sourceMappingURL=textpath.js.map","/**\n * @module ol/geom/LinearRing\n */\nimport {closestSquaredDistanceXY} from '../extent.js';\nimport GeometryLayout from './GeometryLayout.js';\nimport GeometryType from './GeometryType.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {linearRing as linearRingArea} from './flat/area.js';\nimport {assignClosestPoint, maxSquaredDelta} from './flat/closest.js';\nimport {deflateCoordinates} from './flat/deflate.js';\nimport {inflateCoordinates} from './flat/inflate.js';\nimport {douglasPeucker} from './flat/simplify.js';\n\n/**\n * @classdesc\n * Linear ring geometry. Only used as part of polygon; cannot be rendered\n * on its own.\n *\n * @api\n */\nvar LinearRing = /*@__PURE__*/(function (SimpleGeometry) {\n  function LinearRing(coordinates, opt_layout) {\n\n    SimpleGeometry.call(this);\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDelta_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDeltaRevision_ = -1;\n\n    if (opt_layout !== undefined && !Array.isArray(coordinates[0])) {\n      this.setFlatCoordinates(opt_layout, /** @type {Array<number>} */ (coordinates));\n    } else {\n      this.setCoordinates(/** @type {Array<import(\"../coordinate.js\").Coordinate>} */ (coordinates), opt_layout);\n    }\n\n  }\n\n  if ( SimpleGeometry ) LinearRing.__proto__ = SimpleGeometry;\n  LinearRing.prototype = Object.create( SimpleGeometry && SimpleGeometry.prototype );\n  LinearRing.prototype.constructor = LinearRing;\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!LinearRing} Clone.\n   * @override\n   * @api\n   */\n  LinearRing.prototype.clone = function clone () {\n    return new LinearRing(this.flatCoordinates.slice(), this.layout);\n  };\n\n  /**\n   * @inheritDoc\n   */\n  LinearRing.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(maxSquaredDelta(\n        this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return assignClosestPoint(\n      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,\n      this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);\n  };\n\n  /**\n   * Return the area of the linear ring on projected plane.\n   * @return {number} Area (on projected plane).\n   * @api\n   */\n  LinearRing.prototype.getArea = function getArea () {\n    return linearRingArea(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n  };\n\n  /**\n   * Return the coordinates of the linear ring.\n   * @return {Array<import(\"../coordinate.js\").Coordinate>} Coordinates.\n   * @override\n   * @api\n   */\n  LinearRing.prototype.getCoordinates = function getCoordinates () {\n    return inflateCoordinates(\n      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n  };\n\n  /**\n   * @inheritDoc\n   */\n  LinearRing.prototype.getSimplifiedGeometryInternal = function getSimplifiedGeometryInternal (squaredTolerance) {\n    var simplifiedFlatCoordinates = [];\n    simplifiedFlatCoordinates.length = douglasPeucker(\n      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,\n      squaredTolerance, simplifiedFlatCoordinates, 0);\n    return new LinearRing(simplifiedFlatCoordinates, GeometryLayout.XY);\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  LinearRing.prototype.getType = function getType () {\n    return GeometryType.LINEAR_RING;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  LinearRing.prototype.intersectsExtent = function intersectsExtent (extent) {\n    return false;\n  };\n\n  /**\n   * Set the coordinates of the linear ring.\n   * @param {!Array<import(\"../coordinate.js\").Coordinate>} coordinates Coordinates.\n   * @param {GeometryLayout=} opt_layout Layout.\n   * @override\n   * @api\n   */\n  LinearRing.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {\n    this.setLayout(opt_layout, coordinates, 1);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    this.flatCoordinates.length = deflateCoordinates(\n      this.flatCoordinates, 0, coordinates, this.stride);\n    this.changed();\n  };\n\n  return LinearRing;\n}(SimpleGeometry));\n\n\nexport default LinearRing;\n\n//# sourceMappingURL=LinearRing.js.map","/**\n * @module ol/geom/flat/interiorpoint\n */\nimport {numberSafeCompareFunction} from '../../array.js';\nimport {linearRingsContainsXY} from './contains.js';\n\n\n/**\n * Calculates a point that is likely to lie in the interior of the linear rings.\n * Inspired by JTS's com.vividsolutions.jts.geom.Geometry#getInteriorPoint.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {Array<number>} flatCenters Flat centers.\n * @param {number} flatCentersOffset Flat center offset.\n * @param {Array<number>=} opt_dest Destination.\n * @return {Array<number>} Destination point as XYM coordinate, where M is the\n * length of the horizontal intersection that the point belongs to.\n */\nexport function getInteriorPointOfArray(flatCoordinates, offset,\n  ends, stride, flatCenters, flatCentersOffset, opt_dest) {\n  var i, ii, x, x1, x2, y1, y2;\n  var y = flatCenters[flatCentersOffset + 1];\n  /** @type {Array<number>} */\n  var intersections = [];\n  // Calculate intersections with the horizontal line\n  for (var r = 0, rr = ends.length; r < rr; ++r) {\n    var end = ends[r];\n    x1 = flatCoordinates[end - stride];\n    y1 = flatCoordinates[end - stride + 1];\n    for (i = offset; i < end; i += stride) {\n      x2 = flatCoordinates[i];\n      y2 = flatCoordinates[i + 1];\n      if ((y <= y1 && y2 <= y) || (y1 <= y && y <= y2)) {\n        x = (y - y1) / (y2 - y1) * (x2 - x1) + x1;\n        intersections.push(x);\n      }\n      x1 = x2;\n      y1 = y2;\n    }\n  }\n  // Find the longest segment of the horizontal line that has its center point\n  // inside the linear ring.\n  var pointX = NaN;\n  var maxSegmentLength = -Infinity;\n  intersections.sort(numberSafeCompareFunction);\n  x1 = intersections[0];\n  for (i = 1, ii = intersections.length; i < ii; ++i) {\n    x2 = intersections[i];\n    var segmentLength = Math.abs(x2 - x1);\n    if (segmentLength > maxSegmentLength) {\n      x = (x1 + x2) / 2;\n      if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {\n        pointX = x;\n        maxSegmentLength = segmentLength;\n      }\n    }\n    x1 = x2;\n  }\n  if (isNaN(pointX)) {\n    // There is no horizontal line that has its center point inside the linear\n    // ring.  Use the center of the the linear ring's extent.\n    pointX = flatCenters[flatCentersOffset];\n  }\n  if (opt_dest) {\n    opt_dest.push(pointX, y, maxSegmentLength);\n    return opt_dest;\n  } else {\n    return [pointX, y, maxSegmentLength];\n  }\n}\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {Array<number>} flatCenters Flat centers.\n * @return {Array<number>} Interior points as XYM coordinates, where M is the\n * length of the horizontal intersection that the point belongs to.\n */\nexport function getInteriorPointsOfMultiArray(flatCoordinates, offset, endss, stride, flatCenters) {\n  var interiorPoints = [];\n  for (var i = 0, ii = endss.length; i < ii; ++i) {\n    var ends = endss[i];\n    interiorPoints = getInteriorPointOfArray(flatCoordinates,\n      offset, ends, stride, flatCenters, 2 * i, interiorPoints);\n    offset = ends[ends.length - 1];\n  }\n  return interiorPoints;\n}\n\n//# sourceMappingURL=interiorpoint.js.map","/**\n * @module ol/geom/flat/simplify\n */\n// Based on simplify-js https://github.com/mourner/simplify-js\n// Copyright (c) 2012, Vladimir Agafonkin\n// All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n//    1. Redistributions of source code must retain the above copyright notice,\n//       this list of conditions and the following disclaimer.\n//\n//    2. Redistributions in binary form must reproduce the above copyright\n//       notice, this list of conditions and the following disclaimer in the\n//       documentation and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n\nimport {squaredSegmentDistance, squaredDistance} from '../../math.js';\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {boolean} highQuality Highest quality.\n * @param {Array<number>=} opt_simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @return {Array<number>} Simplified line string.\n */\nexport function simplifyLineString(flatCoordinates, offset, end,\n  stride, squaredTolerance, highQuality, opt_simplifiedFlatCoordinates) {\n  var simplifiedFlatCoordinates = opt_simplifiedFlatCoordinates !== undefined ?\n    opt_simplifiedFlatCoordinates : [];\n  if (!highQuality) {\n    end = radialDistance(flatCoordinates, offset, end,\n      stride, squaredTolerance,\n      simplifiedFlatCoordinates, 0);\n    flatCoordinates = simplifiedFlatCoordinates;\n    offset = 0;\n    stride = 2;\n  }\n  simplifiedFlatCoordinates.length = douglasPeucker(\n    flatCoordinates, offset, end, stride, squaredTolerance,\n    simplifiedFlatCoordinates, 0);\n  return simplifiedFlatCoordinates;\n}\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\nexport function douglasPeucker(flatCoordinates, offset, end,\n  stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {\n  var n = (end - offset) / stride;\n  if (n < 3) {\n    for (; offset < end; offset += stride) {\n      simplifiedFlatCoordinates[simplifiedOffset++] =\n          flatCoordinates[offset];\n      simplifiedFlatCoordinates[simplifiedOffset++] =\n          flatCoordinates[offset + 1];\n    }\n    return simplifiedOffset;\n  }\n  /** @type {Array<number>} */\n  var markers = new Array(n);\n  markers[0] = 1;\n  markers[n - 1] = 1;\n  /** @type {Array<number>} */\n  var stack = [offset, end - stride];\n  var index = 0;\n  while (stack.length > 0) {\n    var last = stack.pop();\n    var first = stack.pop();\n    var maxSquaredDistance = 0;\n    var x1 = flatCoordinates[first];\n    var y1 = flatCoordinates[first + 1];\n    var x2 = flatCoordinates[last];\n    var y2 = flatCoordinates[last + 1];\n    for (var i = first + stride; i < last; i += stride) {\n      var x = flatCoordinates[i];\n      var y = flatCoordinates[i + 1];\n      var squaredDistance = squaredSegmentDistance(\n        x, y, x1, y1, x2, y2);\n      if (squaredDistance > maxSquaredDistance) {\n        index = i;\n        maxSquaredDistance = squaredDistance;\n      }\n    }\n    if (maxSquaredDistance > squaredTolerance) {\n      markers[(index - offset) / stride] = 1;\n      if (first + stride < index) {\n        stack.push(first, index);\n      }\n      if (index + stride < last) {\n        stack.push(index, last);\n      }\n    }\n  }\n  for (var i$1 = 0; i$1 < n; ++i$1) {\n    if (markers[i$1]) {\n      simplifiedFlatCoordinates[simplifiedOffset++] =\n          flatCoordinates[offset + i$1 * stride];\n      simplifiedFlatCoordinates[simplifiedOffset++] =\n          flatCoordinates[offset + i$1 * stride + 1];\n    }\n  }\n  return simplifiedOffset;\n}\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<number>} simplifiedEnds Simplified ends.\n * @return {number} Simplified offset.\n */\nexport function douglasPeuckerArray(flatCoordinates, offset,\n  ends, stride, squaredTolerance, simplifiedFlatCoordinates,\n  simplifiedOffset, simplifiedEnds) {\n  for (var i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    simplifiedOffset = douglasPeucker(\n      flatCoordinates, offset, end, stride, squaredTolerance,\n      simplifiedFlatCoordinates, simplifiedOffset);\n    simplifiedEnds.push(simplifiedOffset);\n    offset = end;\n  }\n  return simplifiedOffset;\n}\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<Array<number>>} simplifiedEndss Simplified endss.\n * @return {number} Simplified offset.\n */\nexport function douglasPeuckerMultiArray(\n  flatCoordinates, offset, endss, stride, squaredTolerance,\n  simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {\n  for (var i = 0, ii = endss.length; i < ii; ++i) {\n    var ends = endss[i];\n    var simplifiedEnds = [];\n    simplifiedOffset = douglasPeuckerArray(\n      flatCoordinates, offset, ends, stride, squaredTolerance,\n      simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);\n    simplifiedEndss.push(simplifiedEnds);\n    offset = ends[ends.length - 1];\n  }\n  return simplifiedOffset;\n}\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} squaredTolerance Squared tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\nexport function radialDistance(flatCoordinates, offset, end,\n  stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {\n  if (end <= offset + stride) {\n    // zero or one point, no simplification possible, so copy and return\n    for (; offset < end; offset += stride) {\n      simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];\n      simplifiedFlatCoordinates[simplifiedOffset++] =\n          flatCoordinates[offset + 1];\n    }\n    return simplifiedOffset;\n  }\n  var x1 = flatCoordinates[offset];\n  var y1 = flatCoordinates[offset + 1];\n  // copy first point\n  simplifiedFlatCoordinates[simplifiedOffset++] = x1;\n  simplifiedFlatCoordinates[simplifiedOffset++] = y1;\n  var x2 = x1;\n  var y2 = y1;\n  for (offset += stride; offset < end; offset += stride) {\n    x2 = flatCoordinates[offset];\n    y2 = flatCoordinates[offset + 1];\n    if (squaredDistance(x1, y1, x2, y2) > squaredTolerance) {\n      // copy point at offset\n      simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n      simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n      x1 = x2;\n      y1 = y2;\n    }\n  }\n  if (x2 != x1 || y2 != y1) {\n    // copy last point\n    simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n    simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n  }\n  return simplifiedOffset;\n}\n\n\n/**\n * @param {number} value Value.\n * @param {number} tolerance Tolerance.\n * @return {number} Rounded value.\n */\nexport function snap(value, tolerance) {\n  return tolerance * Math.round(value / tolerance);\n}\n\n\n/**\n * Simplifies a line string using an algorithm designed by Tim Schaub.\n * Coordinates are snapped to the nearest value in a virtual grid and\n * consecutive duplicate coordinates are discarded.  This effectively preserves\n * topology as the simplification of any subsection of a line string is\n * independent of the rest of the line string.  This means that, for examples,\n * the common edge between two polygons will be simplified to the same line\n * string independently in both polygons.  This implementation uses a single\n * pass over the coordinates and eliminates intermediate collinear points.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @return {number} Simplified offset.\n */\nexport function quantize(flatCoordinates, offset, end, stride,\n  tolerance, simplifiedFlatCoordinates, simplifiedOffset) {\n  // do nothing if the line is empty\n  if (offset == end) {\n    return simplifiedOffset;\n  }\n  // snap the first coordinate (P1)\n  var x1 = snap(flatCoordinates[offset], tolerance);\n  var y1 = snap(flatCoordinates[offset + 1], tolerance);\n  offset += stride;\n  // add the first coordinate to the output\n  simplifiedFlatCoordinates[simplifiedOffset++] = x1;\n  simplifiedFlatCoordinates[simplifiedOffset++] = y1;\n  // find the next coordinate that does not snap to the same value as the first\n  // coordinate (P2)\n  var x2, y2;\n  do {\n    x2 = snap(flatCoordinates[offset], tolerance);\n    y2 = snap(flatCoordinates[offset + 1], tolerance);\n    offset += stride;\n    if (offset == end) {\n      // all coordinates snap to the same value, the line collapses to a point\n      // push the last snapped value anyway to ensure that the output contains\n      // at least two points\n      // FIXME should we really return at least two points anyway?\n      simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n      simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n      return simplifiedOffset;\n    }\n  } while (x2 == x1 && y2 == y1);\n  while (offset < end) {\n    // snap the next coordinate (P3)\n    var x3 = snap(flatCoordinates[offset], tolerance);\n    var y3 = snap(flatCoordinates[offset + 1], tolerance);\n    offset += stride;\n    // skip P3 if it is equal to P2\n    if (x3 == x2 && y3 == y2) {\n      continue;\n    }\n    // calculate the delta between P1 and P2\n    var dx1 = x2 - x1;\n    var dy1 = y2 - y1;\n    // calculate the delta between P3 and P1\n    var dx2 = x3 - x1;\n    var dy2 = y3 - y1;\n    // if P1, P2, and P3 are colinear and P3 is further from P1 than P2 is from\n    // P1 in the same direction then P2 is on the straight line between P1 and\n    // P3\n    if ((dx1 * dy2 == dy1 * dx2) &&\n        ((dx1 < 0 && dx2 < dx1) || dx1 == dx2 || (dx1 > 0 && dx2 > dx1)) &&\n        ((dy1 < 0 && dy2 < dy1) || dy1 == dy2 || (dy1 > 0 && dy2 > dy1))) {\n      // discard P2 and set P2 = P3\n      x2 = x3;\n      y2 = y3;\n      continue;\n    }\n    // either P1, P2, and P3 are not colinear, or they are colinear but P3 is\n    // between P3 and P1 or on the opposite half of the line to P2.  add P2,\n    // and continue with P1 = P2 and P2 = P3\n    simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n    simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n    x1 = x2;\n    y1 = y2;\n    x2 = x3;\n    y2 = y3;\n  }\n  // add the last point (P2)\n  simplifiedFlatCoordinates[simplifiedOffset++] = x2;\n  simplifiedFlatCoordinates[simplifiedOffset++] = y2;\n  return simplifiedOffset;\n}\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<number>} simplifiedEnds Simplified ends.\n * @return {number} Simplified offset.\n */\nexport function quantizeArray(\n  flatCoordinates, offset, ends, stride,\n  tolerance,\n  simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {\n  for (var i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    simplifiedOffset = quantize(\n      flatCoordinates, offset, end, stride,\n      tolerance,\n      simplifiedFlatCoordinates, simplifiedOffset);\n    simplifiedEnds.push(simplifiedOffset);\n    offset = end;\n  }\n  return simplifiedOffset;\n}\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} tolerance Tolerance.\n * @param {Array<number>} simplifiedFlatCoordinates Simplified flat\n *     coordinates.\n * @param {number} simplifiedOffset Simplified offset.\n * @param {Array<Array<number>>} simplifiedEndss Simplified endss.\n * @return {number} Simplified offset.\n */\nexport function quantizeMultiArray(\n  flatCoordinates, offset, endss, stride,\n  tolerance,\n  simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {\n  for (var i = 0, ii = endss.length; i < ii; ++i) {\n    var ends = endss[i];\n    var simplifiedEnds = [];\n    simplifiedOffset = quantizeArray(\n      flatCoordinates, offset, ends, stride,\n      tolerance,\n      simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);\n    simplifiedEndss.push(simplifiedEnds);\n    offset = ends[ends.length - 1];\n  }\n  return simplifiedOffset;\n}\n\n//# sourceMappingURL=simplify.js.map","/**\n * @module ol/geom/flat/contains\n */\nimport {forEachCorner} from '../../extent.js';\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} Contains extent.\n */\nexport function linearRingContainsExtent(flatCoordinates, offset, end, stride, extent) {\n  var outside = forEachCorner(extent,\n    /**\n     * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n     * @return {boolean} Contains (x, y).\n     */\n    function(coordinate) {\n      return !linearRingContainsXY(flatCoordinates, offset, end, stride, coordinate[0], coordinate[1]);\n    });\n  return !outside;\n}\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {boolean} Contains (x, y).\n */\nexport function linearRingContainsXY(flatCoordinates, offset, end, stride, x, y) {\n  // http://geomalgorithms.com/a03-_inclusion.html\n  // Copyright 2000 softSurfer, 2012 Dan Sunday\n  // This code may be freely used and modified for any purpose\n  // providing that this copyright notice is included with it.\n  // SoftSurfer makes no warranty for this code, and cannot be held\n  // liable for any real or imagined damage resulting from its use.\n  // Users of this code must verify correctness for their application.\n  var wn = 0;\n  var x1 = flatCoordinates[end - stride];\n  var y1 = flatCoordinates[end - stride + 1];\n  for (; offset < end; offset += stride) {\n    var x2 = flatCoordinates[offset];\n    var y2 = flatCoordinates[offset + 1];\n    if (y1 <= y) {\n      if (y2 > y && ((x2 - x1) * (y - y1)) - ((x - x1) * (y2 - y1)) > 0) {\n        wn++;\n      }\n    } else if (y2 <= y && ((x2 - x1) * (y - y1)) - ((x - x1) * (y2 - y1)) < 0) {\n      wn--;\n    }\n    x1 = x2;\n    y1 = y2;\n  }\n  return wn !== 0;\n}\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {boolean} Contains (x, y).\n */\nexport function linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y) {\n  if (ends.length === 0) {\n    return false;\n  }\n  if (!linearRingContainsXY(flatCoordinates, offset, ends[0], stride, x, y)) {\n    return false;\n  }\n  for (var i = 1, ii = ends.length; i < ii; ++i) {\n    if (linearRingContainsXY(flatCoordinates, ends[i - 1], ends[i], stride, x, y)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @return {boolean} Contains (x, y).\n */\nexport function linearRingssContainsXY(flatCoordinates, offset, endss, stride, x, y) {\n  if (endss.length === 0) {\n    return false;\n  }\n  for (var i = 0, ii = endss.length; i < ii; ++i) {\n    var ends = endss[i];\n    if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {\n      return true;\n    }\n    offset = ends[ends.length - 1];\n  }\n  return false;\n}\n\n//# sourceMappingURL=contains.js.map","/**\n * @module ol/geom/MultiLineString\n */\nimport {extend} from '../array.js';\nimport {closestSquaredDistanceXY} from '../extent.js';\nimport GeometryLayout from './GeometryLayout.js';\nimport GeometryType from './GeometryType.js';\nimport LineString from './LineString.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {assignClosestArrayPoint, arrayMaxSquaredDelta} from './flat/closest.js';\nimport {deflateCoordinatesArray} from './flat/deflate.js';\nimport {inflateCoordinatesArray} from './flat/inflate.js';\nimport {interpolatePoint, lineStringsCoordinateAtM} from './flat/interpolate.js';\nimport {intersectsLineStringArray} from './flat/intersectsextent.js';\nimport {douglasPeuckerArray} from './flat/simplify.js';\n\n/**\n * @classdesc\n * Multi-linestring geometry.\n *\n * @api\n */\nvar MultiLineString = /*@__PURE__*/(function (SimpleGeometry) {\n  function MultiLineString(coordinates, opt_layout, opt_ends) {\n\n    SimpleGeometry.call(this);\n\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n    this.ends_ = [];\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDelta_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDeltaRevision_ = -1;\n\n    if (Array.isArray(coordinates[0])) {\n      this.setCoordinates(/** @type {Array<Array<import(\"../coordinate.js\").Coordinate>>} */ (coordinates), opt_layout);\n    } else if (opt_layout !== undefined && opt_ends) {\n      this.setFlatCoordinates(opt_layout, /** @type {Array<number>} */ (coordinates));\n      this.ends_ = opt_ends;\n    } else {\n      var layout = this.getLayout();\n      var lineStrings = /** @type {Array<LineString>} */ (coordinates);\n      var flatCoordinates = [];\n      var ends = [];\n      for (var i = 0, ii = lineStrings.length; i < ii; ++i) {\n        var lineString = lineStrings[i];\n        if (i === 0) {\n          layout = lineString.getLayout();\n        }\n        extend(flatCoordinates, lineString.getFlatCoordinates());\n        ends.push(flatCoordinates.length);\n      }\n      this.setFlatCoordinates(layout, flatCoordinates);\n      this.ends_ = ends;\n    }\n\n  }\n\n  if ( SimpleGeometry ) MultiLineString.__proto__ = SimpleGeometry;\n  MultiLineString.prototype = Object.create( SimpleGeometry && SimpleGeometry.prototype );\n  MultiLineString.prototype.constructor = MultiLineString;\n\n  /**\n   * Append the passed linestring to the multilinestring.\n   * @param {LineString} lineString LineString.\n   * @api\n   */\n  MultiLineString.prototype.appendLineString = function appendLineString (lineString) {\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = lineString.getFlatCoordinates().slice();\n    } else {\n      extend(this.flatCoordinates, lineString.getFlatCoordinates().slice());\n    }\n    this.ends_.push(this.flatCoordinates.length);\n    this.changed();\n  };\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!MultiLineString} Clone.\n   * @override\n   * @api\n   */\n  MultiLineString.prototype.clone = function clone () {\n    return new MultiLineString(this.flatCoordinates.slice(), this.layout, this.ends_.slice());\n  };\n\n  /**\n   * @inheritDoc\n   */\n  MultiLineString.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(arrayMaxSquaredDelta(\n        this.flatCoordinates, 0, this.ends_, this.stride, 0));\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return assignClosestArrayPoint(\n      this.flatCoordinates, 0, this.ends_, this.stride,\n      this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);\n  };\n\n  /**\n   * Returns the coordinate at `m` using linear interpolation, or `null` if no\n   * such coordinate exists.\n   *\n   * `opt_extrapolate` controls extrapolation beyond the range of Ms in the\n   * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first\n   * M will return the first coordinate and Ms greater than the last M will\n   * return the last coordinate.\n   *\n   * `opt_interpolate` controls interpolation between consecutive LineStrings\n   * within the MultiLineString. If `opt_interpolate` is `true` the coordinates\n   * will be linearly interpolated between the last coordinate of one LineString\n   * and the first coordinate of the next LineString.  If `opt_interpolate` is\n   * `false` then the function will return `null` for Ms falling between\n   * LineStrings.\n   *\n   * @param {number} m M.\n   * @param {boolean=} opt_extrapolate Extrapolate. Default is `false`.\n   * @param {boolean=} opt_interpolate Interpolate. Default is `false`.\n   * @return {import(\"../coordinate.js\").Coordinate} Coordinate.\n   * @api\n   */\n  MultiLineString.prototype.getCoordinateAtM = function getCoordinateAtM (m, opt_extrapolate, opt_interpolate) {\n    if ((this.layout != GeometryLayout.XYM &&\n         this.layout != GeometryLayout.XYZM) ||\n        this.flatCoordinates.length === 0) {\n      return null;\n    }\n    var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;\n    var interpolate = opt_interpolate !== undefined ? opt_interpolate : false;\n    return lineStringsCoordinateAtM(this.flatCoordinates, 0,\n      this.ends_, this.stride, m, extrapolate, interpolate);\n  };\n\n  /**\n   * Return the coordinates of the multilinestring.\n   * @return {Array<Array<import(\"../coordinate.js\").Coordinate>>} Coordinates.\n   * @override\n   * @api\n   */\n  MultiLineString.prototype.getCoordinates = function getCoordinates () {\n    return inflateCoordinatesArray(\n      this.flatCoordinates, 0, this.ends_, this.stride);\n  };\n\n  /**\n   * @return {Array<number>} Ends.\n   */\n  MultiLineString.prototype.getEnds = function getEnds () {\n    return this.ends_;\n  };\n\n  /**\n   * Return the linestring at the specified index.\n   * @param {number} index Index.\n   * @return {LineString} LineString.\n   * @api\n   */\n  MultiLineString.prototype.getLineString = function getLineString (index) {\n    if (index < 0 || this.ends_.length <= index) {\n      return null;\n    }\n    return new LineString(this.flatCoordinates.slice(\n      index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);\n  };\n\n  /**\n   * Return the linestrings of this multilinestring.\n   * @return {Array<LineString>} LineStrings.\n   * @api\n   */\n  MultiLineString.prototype.getLineStrings = function getLineStrings () {\n    var flatCoordinates = this.flatCoordinates;\n    var ends = this.ends_;\n    var layout = this.layout;\n    /** @type {Array<LineString>} */\n    var lineStrings = [];\n    var offset = 0;\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n      var end = ends[i];\n      var lineString = new LineString(flatCoordinates.slice(offset, end), layout);\n      lineStrings.push(lineString);\n      offset = end;\n    }\n    return lineStrings;\n  };\n\n  /**\n   * @return {Array<number>} Flat midpoints.\n   */\n  MultiLineString.prototype.getFlatMidpoints = function getFlatMidpoints () {\n    var midpoints = [];\n    var flatCoordinates = this.flatCoordinates;\n    var offset = 0;\n    var ends = this.ends_;\n    var stride = this.stride;\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n      var end = ends[i];\n      var midpoint = interpolatePoint(\n        flatCoordinates, offset, end, stride, 0.5);\n      extend(midpoints, midpoint);\n      offset = end;\n    }\n    return midpoints;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  MultiLineString.prototype.getSimplifiedGeometryInternal = function getSimplifiedGeometryInternal (squaredTolerance) {\n    var simplifiedFlatCoordinates = [];\n    var simplifiedEnds = [];\n    simplifiedFlatCoordinates.length = douglasPeuckerArray(\n      this.flatCoordinates, 0, this.ends_, this.stride, squaredTolerance,\n      simplifiedFlatCoordinates, 0, simplifiedEnds);\n    return new MultiLineString(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEnds);\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  MultiLineString.prototype.getType = function getType () {\n    return GeometryType.MULTI_LINE_STRING;\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  MultiLineString.prototype.intersectsExtent = function intersectsExtent (extent) {\n    return intersectsLineStringArray(\n      this.flatCoordinates, 0, this.ends_, this.stride, extent);\n  };\n\n  /**\n   * Set the coordinates of the multilinestring.\n   * @param {!Array<Array<import(\"../coordinate.js\").Coordinate>>} coordinates Coordinates.\n   * @param {GeometryLayout=} opt_layout Layout.\n   * @override\n   * @api\n   */\n  MultiLineString.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {\n    this.setLayout(opt_layout, coordinates, 2);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    var ends = deflateCoordinatesArray(\n      this.flatCoordinates, 0, coordinates, this.stride, this.ends_);\n    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];\n    this.changed();\n  };\n\n  return MultiLineString;\n}(SimpleGeometry));\n\n\nexport default MultiLineString;\n\n//# sourceMappingURL=MultiLineString.js.map","/**\n * @module ol/geom/flat/reverse\n */\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n */\nexport function coordinates(flatCoordinates, offset, end, stride) {\n  while (offset < end - stride) {\n    for (var i = 0; i < stride; ++i) {\n      var tmp = flatCoordinates[offset + i];\n      flatCoordinates[offset + i] = flatCoordinates[end - stride + i];\n      flatCoordinates[end - stride + i] = tmp;\n    }\n    offset += stride;\n    end -= stride;\n  }\n}\n\n//# sourceMappingURL=reverse.js.map","/**\n * @module ol/geom/flat/orient\n */\nimport {coordinates as reverseCoordinates} from './reverse.js';\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {boolean} Is clockwise.\n */\nexport function linearRingIsClockwise(flatCoordinates, offset, end, stride) {\n  // http://tinyurl.com/clockwise-method\n  // https://github.com/OSGeo/gdal/blob/trunk/gdal/ogr/ogrlinearring.cpp\n  var edge = 0;\n  var x1 = flatCoordinates[end - stride];\n  var y1 = flatCoordinates[end - stride + 1];\n  for (; offset < end; offset += stride) {\n    var x2 = flatCoordinates[offset];\n    var y2 = flatCoordinates[offset + 1];\n    edge += (x2 - x1) * (y2 + y1);\n    x1 = x2;\n    y1 = y2;\n  }\n  return edge > 0;\n}\n\n\n/**\n * Determines if linear rings are oriented.  By default, left-hand orientation\n * is tested (first ring must be clockwise, remaining rings counter-clockwise).\n * To test for right-hand orientation, use the `opt_right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean=} opt_right Test for right-hand orientation\n *     (counter-clockwise exterior ring and clockwise interior rings).\n * @return {boolean} Rings are correctly oriented.\n */\nexport function linearRingIsOriented(flatCoordinates, offset, ends, stride, opt_right) {\n  var right = opt_right !== undefined ? opt_right : false;\n  for (var i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    var isClockwise = linearRingIsClockwise(\n      flatCoordinates, offset, end, stride);\n    if (i === 0) {\n      if ((right && isClockwise) || (!right && !isClockwise)) {\n        return false;\n      }\n    } else {\n      if ((right && !isClockwise) || (!right && isClockwise)) {\n        return false;\n      }\n    }\n    offset = end;\n  }\n  return true;\n}\n\n\n/**\n * Determines if linear rings are oriented.  By default, left-hand orientation\n * is tested (first ring must be clockwise, remaining rings counter-clockwise).\n * To test for right-hand orientation, use the `opt_right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Array of array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean=} opt_right Test for right-hand orientation\n *     (counter-clockwise exterior ring and clockwise interior rings).\n * @return {boolean} Rings are correctly oriented.\n */\nexport function linearRingsAreOriented(flatCoordinates, offset, endss, stride, opt_right) {\n  for (var i = 0, ii = endss.length; i < ii; ++i) {\n    if (!linearRingIsOriented(\n      flatCoordinates, offset, endss[i], stride, opt_right)) {\n      return false;\n    }\n  }\n  return true;\n}\n\n\n/**\n * Orient coordinates in a flat array of linear rings.  By default, rings\n * are oriented following the left-hand rule (clockwise for exterior and\n * counter-clockwise for interior rings).  To orient according to the\n * right-hand rule, use the `opt_right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {boolean=} opt_right Follow the right-hand rule for orientation.\n * @return {number} End.\n */\nexport function orientLinearRings(flatCoordinates, offset, ends, stride, opt_right) {\n  var right = opt_right !== undefined ? opt_right : false;\n  for (var i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    var isClockwise = linearRingIsClockwise(\n      flatCoordinates, offset, end, stride);\n    var reverse = i === 0 ?\n      (right && isClockwise) || (!right && !isClockwise) :\n      (right && !isClockwise) || (!right && isClockwise);\n    if (reverse) {\n      reverseCoordinates(flatCoordinates, offset, end, stride);\n    }\n    offset = end;\n  }\n  return offset;\n}\n\n\n/**\n * Orient coordinates in a flat array of linear rings.  By default, rings\n * are oriented following the left-hand rule (clockwise for exterior and\n * counter-clockwise for interior rings).  To orient according to the\n * right-hand rule, use the `opt_right` argument.\n *\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Array of array of end indexes.\n * @param {number} stride Stride.\n * @param {boolean=} opt_right Follow the right-hand rule for orientation.\n * @return {number} End.\n */\nexport function orientLinearRingsArray(flatCoordinates, offset, endss, stride, opt_right) {\n  for (var i = 0, ii = endss.length; i < ii; ++i) {\n    offset = orientLinearRings(\n      flatCoordinates, offset, endss[i], stride, opt_right);\n  }\n  return offset;\n}\n\n//# sourceMappingURL=orient.js.map","/**\n * @module ol/geom/GeometryLayout\n */\n\n/**\n * The coordinate layout for geometries, indicating whether a 3rd or 4th z ('Z')\n * or measure ('M') coordinate is available. Supported values are `'XY'`,\n * `'XYZ'`, `'XYM'`, `'XYZM'`.\n * @enum {string}\n */\nexport default {\n  XY: 'XY',\n  XYZ: 'XYZ',\n  XYM: 'XYM',\n  XYZM: 'XYZM'\n};\n\n//# sourceMappingURL=GeometryLayout.js.map","/**\n * @module ol/functions\n */\n\n/**\n * Always returns true.\n * @returns {boolean} true.\n */\nexport function TRUE() {\n  return true;\n}\n\n/**\n * Always returns false.\n * @returns {boolean} false.\n */\nexport function FALSE() {\n  return false;\n}\n\n/**\n * A reusable function, used e.g. as a default for callbacks.\n *\n * @return {void} Nothing.\n */\nexport function VOID() {}\n\n//# sourceMappingURL=functions.js.map","/**\n * @module ol/geom/flat/length\n */\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {number} Length.\n */\nexport function lineStringLength(flatCoordinates, offset, end, stride) {\n  var x1 = flatCoordinates[offset];\n  var y1 = flatCoordinates[offset + 1];\n  var length = 0;\n  for (var i = offset + stride; i < end; i += stride) {\n    var x2 = flatCoordinates[i];\n    var y2 = flatCoordinates[i + 1];\n    length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n    x1 = x2;\n    y1 = y2;\n  }\n  return length;\n}\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {number} Perimeter.\n */\nexport function linearRingLength(flatCoordinates, offset, end, stride) {\n  var perimeter = lineStringLength(flatCoordinates, offset, end, stride);\n  var dx = flatCoordinates[end - stride] - flatCoordinates[offset];\n  var dy = flatCoordinates[end - stride + 1] - flatCoordinates[offset + 1];\n  perimeter += Math.sqrt(dx * dx + dy * dy);\n  return perimeter;\n}\n\n//# sourceMappingURL=length.js.map","/**\n * @module ol/geom/Polygon\n */\nimport {extend} from '../array.js';\nimport {closestSquaredDistanceXY, getCenter} from '../extent.js';\nimport GeometryLayout from './GeometryLayout.js';\nimport GeometryType from './GeometryType.js';\nimport LinearRing from './LinearRing.js';\nimport Point from './Point.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {offset as sphereOffset} from '../sphere.js';\nimport {linearRings as linearRingsArea} from './flat/area.js';\nimport {assignClosestArrayPoint, arrayMaxSquaredDelta} from './flat/closest.js';\nimport {linearRingsContainsXY} from './flat/contains.js';\nimport {deflateCoordinatesArray} from './flat/deflate.js';\nimport {inflateCoordinatesArray} from './flat/inflate.js';\nimport {getInteriorPointOfArray} from './flat/interiorpoint.js';\nimport {intersectsLinearRingArray} from './flat/intersectsextent.js';\nimport {linearRingIsOriented, orientLinearRings} from './flat/orient.js';\nimport {quantizeArray} from './flat/simplify.js';\nimport {modulo} from '../math.js';\n\n/**\n * @classdesc\n * Polygon geometry.\n *\n * @api\n */\nvar Polygon = /*@__PURE__*/(function (SimpleGeometry) {\n  function Polygon(coordinates, opt_layout, opt_ends) {\n\n    SimpleGeometry.call(this);\n\n    /**\n     * @type {Array<number>}\n     * @private\n     */\n    this.ends_ = [];\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.flatInteriorPointRevision_ = -1;\n\n    /**\n     * @private\n     * @type {import(\"../coordinate.js\").Coordinate}\n     */\n    this.flatInteriorPoint_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDelta_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDeltaRevision_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.orientedRevision_ = -1;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.orientedFlatCoordinates_ = null;\n\n    if (opt_layout !== undefined && opt_ends) {\n      this.setFlatCoordinates(opt_layout, /** @type {Array<number>} */ (coordinates));\n      this.ends_ = opt_ends;\n    } else {\n      this.setCoordinates(/** @type {Array<Array<import(\"../coordinate.js\").Coordinate>>} */ (coordinates), opt_layout);\n    }\n\n  }\n\n  if ( SimpleGeometry ) Polygon.__proto__ = SimpleGeometry;\n  Polygon.prototype = Object.create( SimpleGeometry && SimpleGeometry.prototype );\n  Polygon.prototype.constructor = Polygon;\n\n  /**\n   * Append the passed linear ring to this polygon.\n   * @param {LinearRing} linearRing Linear ring.\n   * @api\n   */\n  Polygon.prototype.appendLinearRing = function appendLinearRing (linearRing) {\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = linearRing.getFlatCoordinates().slice();\n    } else {\n      extend(this.flatCoordinates, linearRing.getFlatCoordinates());\n    }\n    this.ends_.push(this.flatCoordinates.length);\n    this.changed();\n  };\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!Polygon} Clone.\n   * @override\n   * @api\n   */\n  Polygon.prototype.clone = function clone () {\n    return new Polygon(this.flatCoordinates.slice(), this.layout, this.ends_.slice());\n  };\n\n  /**\n   * @inheritDoc\n   */\n  Polygon.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(arrayMaxSquaredDelta(\n        this.flatCoordinates, 0, this.ends_, this.stride, 0));\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return assignClosestArrayPoint(\n      this.flatCoordinates, 0, this.ends_, this.stride,\n      this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);\n  };\n\n  /**\n   * @inheritDoc\n   */\n  Polygon.prototype.containsXY = function containsXY (x, y) {\n    return linearRingsContainsXY(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, x, y);\n  };\n\n  /**\n   * Return the area of the polygon on projected plane.\n   * @return {number} Area (on projected plane).\n   * @api\n   */\n  Polygon.prototype.getArea = function getArea () {\n    return linearRingsArea(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride);\n  };\n\n  /**\n   * Get the coordinate array for this geometry.  This array has the structure\n   * of a GeoJSON coordinate array for polygons.\n   *\n   * @param {boolean=} opt_right Orient coordinates according to the right-hand\n   *     rule (counter-clockwise for exterior and clockwise for interior rings).\n   *     If `false`, coordinates will be oriented according to the left-hand rule\n   *     (clockwise for exterior and counter-clockwise for interior rings).\n   *     By default, coordinate orientation will depend on how the geometry was\n   *     constructed.\n   * @return {Array<Array<import(\"../coordinate.js\").Coordinate>>} Coordinates.\n   * @override\n   * @api\n   */\n  Polygon.prototype.getCoordinates = function getCoordinates (opt_right) {\n    var flatCoordinates;\n    if (opt_right !== undefined) {\n      flatCoordinates = this.getOrientedFlatCoordinates().slice();\n      orientLinearRings(\n        flatCoordinates, 0, this.ends_, this.stride, opt_right);\n    } else {\n      flatCoordinates = this.flatCoordinates;\n    }\n\n    return inflateCoordinatesArray(\n      flatCoordinates, 0, this.ends_, this.stride);\n  };\n\n  /**\n   * @return {Array<number>} Ends.\n   */\n  Polygon.prototype.getEnds = function getEnds () {\n    return this.ends_;\n  };\n\n  /**\n   * @return {Array<number>} Interior point.\n   */\n  Polygon.prototype.getFlatInteriorPoint = function getFlatInteriorPoint () {\n    if (this.flatInteriorPointRevision_ != this.getRevision()) {\n      var flatCenter = getCenter(this.getExtent());\n      this.flatInteriorPoint_ = getInteriorPointOfArray(\n        this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride,\n        flatCenter, 0);\n      this.flatInteriorPointRevision_ = this.getRevision();\n    }\n    return this.flatInteriorPoint_;\n  };\n\n  /**\n   * Return an interior point of the polygon.\n   * @return {Point} Interior point as XYM coordinate, where M is the\n   * length of the horizontal intersection that the point belongs to.\n   * @api\n   */\n  Polygon.prototype.getInteriorPoint = function getInteriorPoint () {\n    return new Point(this.getFlatInteriorPoint(), GeometryLayout.XYM);\n  };\n\n  /**\n   * Return the number of rings of the polygon,  this includes the exterior\n   * ring and any interior rings.\n   *\n   * @return {number} Number of rings.\n   * @api\n   */\n  Polygon.prototype.getLinearRingCount = function getLinearRingCount () {\n    return this.ends_.length;\n  };\n\n  /**\n   * Return the Nth linear ring of the polygon geometry. Return `null` if the\n   * given index is out of range.\n   * The exterior linear ring is available at index `0` and the interior rings\n   * at index `1` and beyond.\n   *\n   * @param {number} index Index.\n   * @return {LinearRing} Linear ring.\n   * @api\n   */\n  Polygon.prototype.getLinearRing = function getLinearRing (index) {\n    if (index < 0 || this.ends_.length <= index) {\n      return null;\n    }\n    return new LinearRing(this.flatCoordinates.slice(\n      index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);\n  };\n\n  /**\n   * Return the linear rings of the polygon.\n   * @return {Array<LinearRing>} Linear rings.\n   * @api\n   */\n  Polygon.prototype.getLinearRings = function getLinearRings () {\n    var layout = this.layout;\n    var flatCoordinates = this.flatCoordinates;\n    var ends = this.ends_;\n    var linearRings = [];\n    var offset = 0;\n    for (var i = 0, ii = ends.length; i < ii; ++i) {\n      var end = ends[i];\n      var linearRing = new LinearRing(flatCoordinates.slice(offset, end), layout);\n      linearRings.push(linearRing);\n      offset = end;\n    }\n    return linearRings;\n  };\n\n  /**\n   * @return {Array<number>} Oriented flat coordinates.\n   */\n  Polygon.prototype.getOrientedFlatCoordinates = function getOrientedFlatCoordinates () {\n    if (this.orientedRevision_ != this.getRevision()) {\n      var flatCoordinates = this.flatCoordinates;\n      if (linearRingIsOriented(\n        flatCoordinates, 0, this.ends_, this.stride)) {\n        this.orientedFlatCoordinates_ = flatCoordinates;\n      } else {\n        this.orientedFlatCoordinates_ = flatCoordinates.slice();\n        this.orientedFlatCoordinates_.length =\n            orientLinearRings(\n              this.orientedFlatCoordinates_, 0, this.ends_, this.stride);\n      }\n      this.orientedRevision_ = this.getRevision();\n    }\n    return this.orientedFlatCoordinates_;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  Polygon.prototype.getSimplifiedGeometryInternal = function getSimplifiedGeometryInternal (squaredTolerance) {\n    var simplifiedFlatCoordinates = [];\n    var simplifiedEnds = [];\n    simplifiedFlatCoordinates.length = quantizeArray(\n      this.flatCoordinates, 0, this.ends_, this.stride,\n      Math.sqrt(squaredTolerance),\n      simplifiedFlatCoordinates, 0, simplifiedEnds);\n    return new Polygon(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEnds);\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  Polygon.prototype.getType = function getType () {\n    return GeometryType.POLYGON;\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  Polygon.prototype.intersectsExtent = function intersectsExtent (extent) {\n    return intersectsLinearRingArray(\n      this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, extent);\n  };\n\n  /**\n   * Set the coordinates of the polygon.\n   * @param {!Array<Array<import(\"../coordinate.js\").Coordinate>>} coordinates Coordinates.\n   * @param {GeometryLayout=} opt_layout Layout.\n   * @override\n   * @api\n   */\n  Polygon.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {\n    this.setLayout(opt_layout, coordinates, 2);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    var ends = deflateCoordinatesArray(\n      this.flatCoordinates, 0, coordinates, this.stride, this.ends_);\n    this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];\n    this.changed();\n  };\n\n  return Polygon;\n}(SimpleGeometry));\n\n\nexport default Polygon;\n\n\n/**\n * Create an approximation of a circle on the surface of a sphere.\n * @param {import(\"../coordinate.js\").Coordinate} center Center (`[lon, lat]` in degrees).\n * @param {number} radius The great-circle distance from the center to\n *     the polygon vertices.\n * @param {number=} opt_n Optional number of vertices for the resulting\n *     polygon. Default is `32`.\n * @param {number=} opt_sphereRadius Optional radius for the sphere (defaults to\n *     the Earth's mean radius using the WGS84 ellipsoid).\n * @return {Polygon} The \"circular\" polygon.\n * @api\n */\nexport function circular(center, radius, opt_n, opt_sphereRadius) {\n  var n = opt_n ? opt_n : 32;\n  /** @type {Array<number>} */\n  var flatCoordinates = [];\n  for (var i = 0; i < n; ++i) {\n    extend(flatCoordinates, sphereOffset(center, radius, 2 * Math.PI * i / n, opt_sphereRadius));\n  }\n  flatCoordinates.push(flatCoordinates[0], flatCoordinates[1]);\n  return new Polygon(flatCoordinates, GeometryLayout.XY, [flatCoordinates.length]);\n}\n\n\n/**\n * Create a polygon from an extent. The layout used is `XY`.\n * @param {import(\"../extent.js\").Extent} extent The extent.\n * @return {Polygon} The polygon.\n * @api\n */\nexport function fromExtent(extent) {\n  var minX = extent[0];\n  var minY = extent[1];\n  var maxX = extent[2];\n  var maxY = extent[3];\n  var flatCoordinates =\n      [minX, minY, minX, maxY, maxX, maxY, maxX, minY, minX, minY];\n  return new Polygon(flatCoordinates, GeometryLayout.XY, [flatCoordinates.length]);\n}\n\n\n/**\n * Create a regular polygon from a circle.\n * @param {import(\"./Circle.js\").default} circle Circle geometry.\n * @param {number=} opt_sides Number of sides of the polygon. Default is 32.\n * @param {number=} opt_angle Start angle for the first vertex of the polygon in\n *     radians. Default is 0.\n * @return {Polygon} Polygon geometry.\n * @api\n */\nexport function fromCircle(circle, opt_sides, opt_angle) {\n  var sides = opt_sides ? opt_sides : 32;\n  var stride = circle.getStride();\n  var layout = circle.getLayout();\n  var center = circle.getCenter();\n  var arrayLength = stride * (sides + 1);\n  var flatCoordinates = new Array(arrayLength);\n  for (var i = 0; i < arrayLength; i += stride) {\n    flatCoordinates[i] = 0;\n    flatCoordinates[i + 1] = 0;\n    for (var j = 2; j < stride; j++) {\n      flatCoordinates[i + j] = center[j];\n    }\n  }\n  var ends = [flatCoordinates.length];\n  var polygon = new Polygon(flatCoordinates, layout, ends);\n  makeRegular(polygon, center, circle.getRadius(), opt_angle);\n  return polygon;\n}\n\n\n/**\n * Modify the coordinates of a polygon to make it a regular polygon.\n * @param {Polygon} polygon Polygon geometry.\n * @param {import(\"../coordinate.js\").Coordinate} center Center of the regular polygon.\n * @param {number} radius Radius of the regular polygon.\n * @param {number=} opt_angle Start angle for the first vertex of the polygon in\n *     radians. Default is 0.\n */\nexport function makeRegular(polygon, center, radius, opt_angle) {\n  var flatCoordinates = polygon.getFlatCoordinates();\n  var stride = polygon.getStride();\n  var sides = flatCoordinates.length / stride - 1;\n  var startAngle = opt_angle ? opt_angle : 0;\n  for (var i = 0; i <= sides; ++i) {\n    var offset = i * stride;\n    var angle = startAngle + (modulo(i, sides) * 2 * Math.PI / sides);\n    flatCoordinates[offset] = center[0] + (radius * Math.cos(angle));\n    flatCoordinates[offset + 1] = center[1] + (radius * Math.sin(angle));\n  }\n  polygon.changed();\n}\n\n//# sourceMappingURL=Polygon.js.map","/**\n * @module ol/geom/LineString\n */\nimport {extend} from '../array.js';\nimport {closestSquaredDistanceXY} from '../extent.js';\nimport GeometryLayout from './GeometryLayout.js';\nimport GeometryType from './GeometryType.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {assignClosestPoint, maxSquaredDelta} from './flat/closest.js';\nimport {deflateCoordinates} from './flat/deflate.js';\nimport {inflateCoordinates} from './flat/inflate.js';\nimport {interpolatePoint, lineStringCoordinateAtM} from './flat/interpolate.js';\nimport {intersectsLineString} from './flat/intersectsextent.js';\nimport {lineStringLength} from './flat/length.js';\nimport {forEach as forEachSegment} from './flat/segments.js';\nimport {douglasPeucker} from './flat/simplify.js';\n\n/**\n * @classdesc\n * Linestring geometry.\n *\n * @api\n */\nvar LineString = /*@__PURE__*/(function (SimpleGeometry) {\n  function LineString(coordinates, opt_layout) {\n\n    SimpleGeometry.call(this);\n\n    /**\n     * @private\n     * @type {import(\"../coordinate.js\").Coordinate}\n     */\n    this.flatMidpoint_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.flatMidpointRevision_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDelta_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDeltaRevision_ = -1;\n\n    if (opt_layout !== undefined && !Array.isArray(coordinates[0])) {\n      this.setFlatCoordinates(opt_layout, /** @type {Array<number>} */ (coordinates));\n    } else {\n      this.setCoordinates(/** @type {Array<import(\"../coordinate.js\").Coordinate>} */ (coordinates), opt_layout);\n    }\n\n  }\n\n  if ( SimpleGeometry ) LineString.__proto__ = SimpleGeometry;\n  LineString.prototype = Object.create( SimpleGeometry && SimpleGeometry.prototype );\n  LineString.prototype.constructor = LineString;\n\n  /**\n   * Append the passed coordinate to the coordinates of the linestring.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @api\n   */\n  LineString.prototype.appendCoordinate = function appendCoordinate (coordinate) {\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = coordinate.slice();\n    } else {\n      extend(this.flatCoordinates, coordinate);\n    }\n    this.changed();\n  };\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!LineString} Clone.\n   * @override\n   * @api\n   */\n  LineString.prototype.clone = function clone () {\n    return new LineString(this.flatCoordinates.slice(), this.layout);\n  };\n\n  /**\n   * @inheritDoc\n   */\n  LineString.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(maxSquaredDelta(\n        this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return assignClosestPoint(\n      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,\n      this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);\n  };\n\n  /**\n   * Iterate over each segment, calling the provided callback.\n   * If the callback returns a truthy value the function returns that\n   * value immediately. Otherwise the function returns `false`.\n   *\n   * @param {function(this: S, import(\"../coordinate.js\").Coordinate, import(\"../coordinate.js\").Coordinate): T} callback Function\n   *     called for each segment.\n   * @return {T|boolean} Value.\n   * @template T,S\n   * @api\n   */\n  LineString.prototype.forEachSegment = function forEachSegment$1 (callback) {\n    return forEachSegment(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, callback);\n  };\n\n  /**\n   * Returns the coordinate at `m` using linear interpolation, or `null` if no\n   * such coordinate exists.\n   *\n   * `opt_extrapolate` controls extrapolation beyond the range of Ms in the\n   * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first\n   * M will return the first coordinate and Ms greater than the last M will\n   * return the last coordinate.\n   *\n   * @param {number} m M.\n   * @param {boolean=} opt_extrapolate Extrapolate. Default is `false`.\n   * @return {import(\"../coordinate.js\").Coordinate} Coordinate.\n   * @api\n   */\n  LineString.prototype.getCoordinateAtM = function getCoordinateAtM (m, opt_extrapolate) {\n    if (this.layout != GeometryLayout.XYM &&\n        this.layout != GeometryLayout.XYZM) {\n      return null;\n    }\n    var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;\n    return lineStringCoordinateAtM(this.flatCoordinates, 0,\n      this.flatCoordinates.length, this.stride, m, extrapolate);\n  };\n\n  /**\n   * Return the coordinates of the linestring.\n   * @return {Array<import(\"../coordinate.js\").Coordinate>} Coordinates.\n   * @override\n   * @api\n   */\n  LineString.prototype.getCoordinates = function getCoordinates () {\n    return inflateCoordinates(\n      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n  };\n\n  /**\n   * Return the coordinate at the provided fraction along the linestring.\n   * The `fraction` is a number between 0 and 1, where 0 is the start of the\n   * linestring and 1 is the end.\n   * @param {number} fraction Fraction.\n   * @param {import(\"../coordinate.js\").Coordinate=} opt_dest Optional coordinate whose values will\n   *     be modified. If not provided, a new coordinate will be returned.\n   * @return {import(\"../coordinate.js\").Coordinate} Coordinate of the interpolated point.\n   * @api\n   */\n  LineString.prototype.getCoordinateAt = function getCoordinateAt (fraction, opt_dest) {\n    return interpolatePoint(\n      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,\n      fraction, opt_dest);\n  };\n\n  /**\n   * Return the length of the linestring on projected plane.\n   * @return {number} Length (on projected plane).\n   * @api\n   */\n  LineString.prototype.getLength = function getLength () {\n    return lineStringLength(\n      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n  };\n\n  /**\n   * @return {Array<number>} Flat midpoint.\n   */\n  LineString.prototype.getFlatMidpoint = function getFlatMidpoint () {\n    if (this.flatMidpointRevision_ != this.getRevision()) {\n      this.flatMidpoint_ = this.getCoordinateAt(0.5, this.flatMidpoint_);\n      this.flatMidpointRevision_ = this.getRevision();\n    }\n    return this.flatMidpoint_;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  LineString.prototype.getSimplifiedGeometryInternal = function getSimplifiedGeometryInternal (squaredTolerance) {\n    var simplifiedFlatCoordinates = [];\n    simplifiedFlatCoordinates.length = douglasPeucker(\n      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,\n      squaredTolerance, simplifiedFlatCoordinates, 0);\n    return new LineString(simplifiedFlatCoordinates, GeometryLayout.XY);\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  LineString.prototype.getType = function getType () {\n    return GeometryType.LINE_STRING;\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  LineString.prototype.intersectsExtent = function intersectsExtent (extent) {\n    return intersectsLineString(\n      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride,\n      extent);\n  };\n\n  /**\n   * Set the coordinates of the linestring.\n   * @param {!Array<import(\"../coordinate.js\").Coordinate>} coordinates Coordinates.\n   * @param {GeometryLayout=} opt_layout Layout.\n   * @override\n   * @api\n   */\n  LineString.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {\n    this.setLayout(opt_layout, coordinates, 1);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    this.flatCoordinates.length = deflateCoordinates(\n      this.flatCoordinates, 0, coordinates, this.stride);\n    this.changed();\n  };\n\n  return LineString;\n}(SimpleGeometry));\n\n\nexport default LineString;\n\n//# sourceMappingURL=LineString.js.map","/**\n * @module ol/geom/flat/straightchunk\n */\n\n\n/**\n * @param {number} maxAngle Maximum acceptable angle delta between segments.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {Array<number>} Start and end of the first suitable chunk of the\n * given `flatCoordinates`.\n */\nexport function matchingChunk(maxAngle, flatCoordinates, offset, end, stride) {\n  var chunkStart = offset;\n  var chunkEnd = offset;\n  var chunkM = 0;\n  var m = 0;\n  var start = offset;\n  var acos, i, m12, m23, x1, y1, x12, y12, x23, y23;\n  for (i = offset; i < end; i += stride) {\n    var x2 = flatCoordinates[i];\n    var y2 = flatCoordinates[i + 1];\n    if (x1 !== undefined) {\n      x23 = x2 - x1;\n      y23 = y2 - y1;\n      m23 = Math.sqrt(x23 * x23 + y23 * y23);\n      if (x12 !== undefined) {\n        m += m12;\n        acos = Math.acos((x12 * x23 + y12 * y23) / (m12 * m23));\n        if (acos > maxAngle) {\n          if (m > chunkM) {\n            chunkM = m;\n            chunkStart = start;\n            chunkEnd = i;\n          }\n          m = 0;\n          start = i - stride;\n        }\n      }\n      m12 = m23;\n      x12 = x23;\n      y12 = y23;\n    }\n    x1 = x2;\n    y1 = y2;\n  }\n  m += m23;\n  return m > chunkM ? [start, i] : [chunkStart, chunkEnd];\n}\n\n//# sourceMappingURL=straightchunk.js.map","/**\n * @module ol/geom/flat/center\n */\nimport {createEmpty, createOrUpdateFromFlatCoordinates} from '../../extent.js';\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @return {Array<number>} Flat centers.\n */\nexport function linearRingss(flatCoordinates, offset, endss, stride) {\n  var flatCenters = [];\n  var extent = createEmpty();\n  for (var i = 0, ii = endss.length; i < ii; ++i) {\n    var ends = endss[i];\n    extent = createOrUpdateFromFlatCoordinates(flatCoordinates, offset, ends[0], stride);\n    flatCenters.push((extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2);\n    offset = ends[ends.length - 1];\n  }\n  return flatCenters;\n}\n\n//# sourceMappingURL=center.js.map","/**\n * @module ol/geom/MultiPolygon\n */\nimport {extend} from '../array.js';\nimport {closestSquaredDistanceXY} from '../extent.js';\nimport GeometryLayout from './GeometryLayout.js';\nimport GeometryType from './GeometryType.js';\nimport MultiPoint from './MultiPoint.js';\nimport Polygon from './Polygon.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {linearRingss as linearRingssArea} from './flat/area.js';\nimport {linearRingss as linearRingssCenter} from './flat/center.js';\nimport {assignClosestMultiArrayPoint, multiArrayMaxSquaredDelta} from './flat/closest.js';\nimport {linearRingssContainsXY} from './flat/contains.js';\nimport {deflateMultiCoordinatesArray} from './flat/deflate.js';\nimport {inflateMultiCoordinatesArray} from './flat/inflate.js';\nimport {getInteriorPointsOfMultiArray} from './flat/interiorpoint.js';\nimport {intersectsLinearRingMultiArray} from './flat/intersectsextent.js';\nimport {linearRingsAreOriented, orientLinearRingsArray} from './flat/orient.js';\nimport {quantizeMultiArray} from './flat/simplify.js';\n\n/**\n * @classdesc\n * Multi-polygon geometry.\n *\n * @api\n */\nvar MultiPolygon = /*@__PURE__*/(function (SimpleGeometry) {\n  function MultiPolygon(coordinates, opt_layout, opt_endss) {\n\n    SimpleGeometry.call(this);\n\n    /**\n     * @type {Array<Array<number>>}\n     * @private\n     */\n    this.endss_ = [];\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.flatInteriorPointsRevision_ = -1;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.flatInteriorPoints_ = null;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDelta_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.maxDeltaRevision_ = -1;\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.orientedRevision_ = -1;\n\n    /**\n     * @private\n     * @type {Array<number>}\n     */\n    this.orientedFlatCoordinates_ = null;\n\n    if (!opt_endss && !Array.isArray(coordinates[0])) {\n      var layout = this.getLayout();\n      var polygons = /** @type {Array<Polygon>} */ (coordinates);\n      var flatCoordinates = [];\n      var endss = [];\n      for (var i = 0, ii = polygons.length; i < ii; ++i) {\n        var polygon = polygons[i];\n        if (i === 0) {\n          layout = polygon.getLayout();\n        }\n        var offset = flatCoordinates.length;\n        var ends = polygon.getEnds();\n        for (var j = 0, jj = ends.length; j < jj; ++j) {\n          ends[j] += offset;\n        }\n        extend(flatCoordinates, polygon.getFlatCoordinates());\n        endss.push(ends);\n      }\n      opt_layout = layout;\n      coordinates = flatCoordinates;\n      opt_endss = endss;\n    }\n    if (opt_layout !== undefined && opt_endss) {\n      this.setFlatCoordinates(opt_layout, /** @type {Array<number>} */ (coordinates));\n      this.endss_ = opt_endss;\n    } else {\n      this.setCoordinates(/** @type {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} */ (coordinates),\n        opt_layout);\n    }\n\n  }\n\n  if ( SimpleGeometry ) MultiPolygon.__proto__ = SimpleGeometry;\n  MultiPolygon.prototype = Object.create( SimpleGeometry && SimpleGeometry.prototype );\n  MultiPolygon.prototype.constructor = MultiPolygon;\n\n  /**\n   * Append the passed polygon to this multipolygon.\n   * @param {Polygon} polygon Polygon.\n   * @api\n   */\n  MultiPolygon.prototype.appendPolygon = function appendPolygon (polygon) {\n    /** @type {Array<number>} */\n    var ends;\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = polygon.getFlatCoordinates().slice();\n      ends = polygon.getEnds().slice();\n      this.endss_.push();\n    } else {\n      var offset = this.flatCoordinates.length;\n      extend(this.flatCoordinates, polygon.getFlatCoordinates());\n      ends = polygon.getEnds().slice();\n      for (var i = 0, ii = ends.length; i < ii; ++i) {\n        ends[i] += offset;\n      }\n    }\n    this.endss_.push(ends);\n    this.changed();\n  };\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!MultiPolygon} Clone.\n   * @override\n   * @api\n   */\n  MultiPolygon.prototype.clone = function clone () {\n    var len = this.endss_.length;\n    var newEndss = new Array(len);\n    for (var i = 0; i < len; ++i) {\n      newEndss[i] = this.endss_[i].slice();\n    }\n\n    return new MultiPolygon(\n      this.flatCoordinates.slice(), this.layout, newEndss);\n  };\n\n  /**\n   * @inheritDoc\n   */\n  MultiPolygon.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    if (this.maxDeltaRevision_ != this.getRevision()) {\n      this.maxDelta_ = Math.sqrt(multiArrayMaxSquaredDelta(\n        this.flatCoordinates, 0, this.endss_, this.stride, 0));\n      this.maxDeltaRevision_ = this.getRevision();\n    }\n    return assignClosestMultiArrayPoint(\n      this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride,\n      this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);\n  };\n\n  /**\n   * @inheritDoc\n   */\n  MultiPolygon.prototype.containsXY = function containsXY (x, y) {\n    return linearRingssContainsXY(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, x, y);\n  };\n\n  /**\n   * Return the area of the multipolygon on projected plane.\n   * @return {number} Area (on projected plane).\n   * @api\n   */\n  MultiPolygon.prototype.getArea = function getArea () {\n    return linearRingssArea(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride);\n  };\n\n  /**\n   * Get the coordinate array for this geometry.  This array has the structure\n   * of a GeoJSON coordinate array for multi-polygons.\n   *\n   * @param {boolean=} opt_right Orient coordinates according to the right-hand\n   *     rule (counter-clockwise for exterior and clockwise for interior rings).\n   *     If `false`, coordinates will be oriented according to the left-hand rule\n   *     (clockwise for exterior and counter-clockwise for interior rings).\n   *     By default, coordinate orientation will depend on how the geometry was\n   *     constructed.\n   * @return {Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} Coordinates.\n   * @override\n   * @api\n   */\n  MultiPolygon.prototype.getCoordinates = function getCoordinates (opt_right) {\n    var flatCoordinates;\n    if (opt_right !== undefined) {\n      flatCoordinates = this.getOrientedFlatCoordinates().slice();\n      orientLinearRingsArray(\n        flatCoordinates, 0, this.endss_, this.stride, opt_right);\n    } else {\n      flatCoordinates = this.flatCoordinates;\n    }\n\n    return inflateMultiCoordinatesArray(\n      flatCoordinates, 0, this.endss_, this.stride);\n  };\n\n  /**\n   * @return {Array<Array<number>>} Endss.\n   */\n  MultiPolygon.prototype.getEndss = function getEndss () {\n    return this.endss_;\n  };\n\n  /**\n   * @return {Array<number>} Flat interior points.\n   */\n  MultiPolygon.prototype.getFlatInteriorPoints = function getFlatInteriorPoints () {\n    if (this.flatInteriorPointsRevision_ != this.getRevision()) {\n      var flatCenters = linearRingssCenter(\n        this.flatCoordinates, 0, this.endss_, this.stride);\n      this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(\n        this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride,\n        flatCenters);\n      this.flatInteriorPointsRevision_ = this.getRevision();\n    }\n    return this.flatInteriorPoints_;\n  };\n\n  /**\n   * Return the interior points as {@link module:ol/geom/MultiPoint multipoint}.\n   * @return {MultiPoint} Interior points as XYM coordinates, where M is\n   * the length of the horizontal intersection that the point belongs to.\n   * @api\n   */\n  MultiPolygon.prototype.getInteriorPoints = function getInteriorPoints () {\n    return new MultiPoint(this.getFlatInteriorPoints().slice(), GeometryLayout.XYM);\n  };\n\n  /**\n   * @return {Array<number>} Oriented flat coordinates.\n   */\n  MultiPolygon.prototype.getOrientedFlatCoordinates = function getOrientedFlatCoordinates () {\n    if (this.orientedRevision_ != this.getRevision()) {\n      var flatCoordinates = this.flatCoordinates;\n      if (linearRingsAreOriented(\n        flatCoordinates, 0, this.endss_, this.stride)) {\n        this.orientedFlatCoordinates_ = flatCoordinates;\n      } else {\n        this.orientedFlatCoordinates_ = flatCoordinates.slice();\n        this.orientedFlatCoordinates_.length =\n            orientLinearRingsArray(\n              this.orientedFlatCoordinates_, 0, this.endss_, this.stride);\n      }\n      this.orientedRevision_ = this.getRevision();\n    }\n    return this.orientedFlatCoordinates_;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  MultiPolygon.prototype.getSimplifiedGeometryInternal = function getSimplifiedGeometryInternal (squaredTolerance) {\n    var simplifiedFlatCoordinates = [];\n    var simplifiedEndss = [];\n    simplifiedFlatCoordinates.length = quantizeMultiArray(\n      this.flatCoordinates, 0, this.endss_, this.stride,\n      Math.sqrt(squaredTolerance),\n      simplifiedFlatCoordinates, 0, simplifiedEndss);\n    return new MultiPolygon(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEndss);\n  };\n\n  /**\n   * Return the polygon at the specified index.\n   * @param {number} index Index.\n   * @return {Polygon} Polygon.\n   * @api\n   */\n  MultiPolygon.prototype.getPolygon = function getPolygon (index) {\n    if (index < 0 || this.endss_.length <= index) {\n      return null;\n    }\n    var offset;\n    if (index === 0) {\n      offset = 0;\n    } else {\n      var prevEnds = this.endss_[index - 1];\n      offset = prevEnds[prevEnds.length - 1];\n    }\n    var ends = this.endss_[index].slice();\n    var end = ends[ends.length - 1];\n    if (offset !== 0) {\n      for (var i = 0, ii = ends.length; i < ii; ++i) {\n        ends[i] -= offset;\n      }\n    }\n    return new Polygon(this.flatCoordinates.slice(offset, end), this.layout, ends);\n  };\n\n  /**\n   * Return the polygons of this multipolygon.\n   * @return {Array<Polygon>} Polygons.\n   * @api\n   */\n  MultiPolygon.prototype.getPolygons = function getPolygons () {\n    var layout = this.layout;\n    var flatCoordinates = this.flatCoordinates;\n    var endss = this.endss_;\n    var polygons = [];\n    var offset = 0;\n    for (var i = 0, ii = endss.length; i < ii; ++i) {\n      var ends = endss[i].slice();\n      var end = ends[ends.length - 1];\n      if (offset !== 0) {\n        for (var j = 0, jj = ends.length; j < jj; ++j) {\n          ends[j] -= offset;\n        }\n      }\n      var polygon = new Polygon(flatCoordinates.slice(offset, end), layout, ends);\n      polygons.push(polygon);\n      offset = end;\n    }\n    return polygons;\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  MultiPolygon.prototype.getType = function getType () {\n    return GeometryType.MULTI_POLYGON;\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  MultiPolygon.prototype.intersectsExtent = function intersectsExtent (extent) {\n    return intersectsLinearRingMultiArray(\n      this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, extent);\n  };\n\n  /**\n   * Set the coordinates of the multipolygon.\n   * @param {!Array<Array<Array<import(\"../coordinate.js\").Coordinate>>>} coordinates Coordinates.\n   * @param {GeometryLayout=} opt_layout Layout.\n   * @override\n   * @api\n   */\n  MultiPolygon.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {\n    this.setLayout(opt_layout, coordinates, 3);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    var endss = deflateMultiCoordinatesArray(\n      this.flatCoordinates, 0, coordinates, this.stride, this.endss_);\n    if (endss.length === 0) {\n      this.flatCoordinates.length = 0;\n    } else {\n      var lastEnds = endss[endss.length - 1];\n      this.flatCoordinates.length = lastEnds.length === 0 ?\n        0 : lastEnds[lastEnds.length - 1];\n    }\n    this.changed();\n  };\n\n  return MultiPolygon;\n}(SimpleGeometry));\n\n\nexport default MultiPolygon;\n\n//# sourceMappingURL=MultiPolygon.js.map","/**\n * @module ol/geom/Geometry\n */\nimport {abstract} from '../util.js';\nimport BaseObject from '../Object.js';\nimport {createEmpty, getHeight, returnOrUpdate} from '../extent.js';\nimport {transform2D} from './flat/transform.js';\nimport {get as getProjection, getTransform} from '../proj.js';\nimport Units from '../proj/Units.js';\nimport {create as createTransform, compose as composeTransform} from '../transform.js';\n\n\n/**\n * @type {import(\"../transform.js\").Transform}\n */\nvar tmpTransform = createTransform();\n\n\n/**\n * @classdesc\n * Abstract base class; normally only used for creating subclasses and not\n * instantiated in apps.\n * Base class for vector geometries.\n *\n * To get notified of changes to the geometry, register a listener for the\n * generic `change` event on your geometry instance.\n *\n * @abstract\n * @api\n */\nvar Geometry = /*@__PURE__*/(function (BaseObject) {\n  function Geometry() {\n\n    BaseObject.call(this);\n\n    /**\n     * @private\n     * @type {import(\"../extent.js\").Extent}\n     */\n    this.extent_ = createEmpty();\n\n    /**\n     * @private\n     * @type {number}\n     */\n    this.extentRevision_ = -1;\n\n    /**\n     * @protected\n     * @type {Object<string, Geometry>}\n     */\n    this.simplifiedGeometryCache = {};\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.simplifiedGeometryMaxMinSquaredTolerance = 0;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.simplifiedGeometryRevision = 0;\n\n  }\n\n  if ( BaseObject ) Geometry.__proto__ = BaseObject;\n  Geometry.prototype = Object.create( BaseObject && BaseObject.prototype );\n  Geometry.prototype.constructor = Geometry;\n\n  /**\n   * Make a complete copy of the geometry.\n   * @abstract\n   * @return {!Geometry} Clone.\n   */\n  Geometry.prototype.clone = function clone () {\n    return abstract();\n  };\n\n  /**\n   * @abstract\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @param {import(\"../coordinate.js\").Coordinate} closestPoint Closest point.\n   * @param {number} minSquaredDistance Minimum squared distance.\n   * @return {number} Minimum squared distance.\n   */\n  Geometry.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {\n    return abstract();\n  };\n\n  /**\n   * @param {number} x X.\n   * @param {number} y Y.\n   * @return {boolean} Contains (x, y).\n   */\n  Geometry.prototype.containsXY = function containsXY (x, y) {\n    return false;\n  };\n\n  /**\n   * Return the closest point of the geometry to the passed point as\n   * {@link module:ol/coordinate~Coordinate coordinate}.\n   * @param {import(\"../coordinate.js\").Coordinate} point Point.\n   * @param {import(\"../coordinate.js\").Coordinate=} opt_closestPoint Closest point.\n   * @return {import(\"../coordinate.js\").Coordinate} Closest point.\n   * @api\n   */\n  Geometry.prototype.getClosestPoint = function getClosestPoint (point, opt_closestPoint) {\n    var closestPoint = opt_closestPoint ? opt_closestPoint : [NaN, NaN];\n    this.closestPointXY(point[0], point[1], closestPoint, Infinity);\n    return closestPoint;\n  };\n\n  /**\n   * Returns true if this geometry includes the specified coordinate. If the\n   * coordinate is on the boundary of the geometry, returns false.\n   * @param {import(\"../coordinate.js\").Coordinate} coordinate Coordinate.\n   * @return {boolean} Contains coordinate.\n   * @api\n   */\n  Geometry.prototype.intersectsCoordinate = function intersectsCoordinate (coordinate) {\n    return this.containsXY(coordinate[0], coordinate[1]);\n  };\n\n  /**\n   * @abstract\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @protected\n   * @return {import(\"../extent.js\").Extent} extent Extent.\n   */\n  Geometry.prototype.computeExtent = function computeExtent (extent) {\n    return abstract();\n  };\n\n  /**\n   * Get the extent of the geometry.\n   * @param {import(\"../extent.js\").Extent=} opt_extent Extent.\n   * @return {import(\"../extent.js\").Extent} extent Extent.\n   * @api\n   */\n  Geometry.prototype.getExtent = function getExtent (opt_extent) {\n    if (this.extentRevision_ != this.getRevision()) {\n      this.extent_ = this.computeExtent(this.extent_);\n      this.extentRevision_ = this.getRevision();\n    }\n    return returnOrUpdate(this.extent_, opt_extent);\n  };\n\n  /**\n   * Rotate the geometry around a given coordinate. This modifies the geometry\n   * coordinates in place.\n   * @abstract\n   * @param {number} angle Rotation angle in radians.\n   * @param {import(\"../coordinate.js\").Coordinate} anchor The rotation center.\n   * @api\n   */\n  Geometry.prototype.rotate = function rotate (angle, anchor) {\n    abstract();\n  };\n\n  /**\n   * Scale the geometry (with an optional origin).  This modifies the geometry\n   * coordinates in place.\n   * @abstract\n   * @param {number} sx The scaling factor in the x-direction.\n   * @param {number=} opt_sy The scaling factor in the y-direction (defaults to\n   *     sx).\n   * @param {import(\"../coordinate.js\").Coordinate=} opt_anchor The scale origin (defaults to the center\n   *     of the geometry extent).\n   * @api\n   */\n  Geometry.prototype.scale = function scale (sx, opt_sy, opt_anchor) {\n    abstract();\n  };\n\n  /**\n   * Create a simplified version of this geometry.  For linestrings, this uses\n   * the the {@link\n   * https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm\n   * Douglas Peucker} algorithm.  For polygons, a quantization-based\n   * simplification is used to preserve topology.\n   * @param {number} tolerance The tolerance distance for simplification.\n   * @return {Geometry} A new, simplified version of the original geometry.\n   * @api\n   */\n  Geometry.prototype.simplify = function simplify (tolerance) {\n    return this.getSimplifiedGeometry(tolerance * tolerance);\n  };\n\n  /**\n   * Create a simplified version of this geometry using the Douglas Peucker\n   * algorithm.\n   * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.\n   * @abstract\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {Geometry} Simplified geometry.\n   */\n  Geometry.prototype.getSimplifiedGeometry = function getSimplifiedGeometry (squaredTolerance) {\n    return abstract();\n  };\n\n  /**\n   * Get the type of this geometry.\n   * @abstract\n   * @return {import(\"./GeometryType.js\").default} Geometry type.\n   */\n  Geometry.prototype.getType = function getType () {\n    return abstract();\n  };\n\n  /**\n   * Apply a transform function to each coordinate of the geometry.\n   * The geometry is modified in place.\n   * If you do not want the geometry modified in place, first `clone()` it and\n   * then use this function on the clone.\n   * @abstract\n   * @param {import(\"../proj.js\").TransformFunction} transformFn Transform.\n   */\n  Geometry.prototype.applyTransform = function applyTransform (transformFn) {\n    abstract();\n  };\n\n  /**\n   * Test if the geometry and the passed extent intersect.\n   * @abstract\n   * @param {import(\"../extent.js\").Extent} extent Extent.\n   * @return {boolean} `true` if the geometry and the extent intersect.\n   */\n  Geometry.prototype.intersectsExtent = function intersectsExtent (extent) {\n    return abstract();\n  };\n\n  /**\n   * Translate the geometry.  This modifies the geometry coordinates in place.  If\n   * instead you want a new geometry, first `clone()` this geometry.\n   * @abstract\n   * @param {number} deltaX Delta X.\n   * @param {number} deltaY Delta Y.\n   * @api\n   */\n  Geometry.prototype.translate = function translate (deltaX, deltaY) {\n    abstract();\n  };\n\n  /**\n   * Transform each coordinate of the geometry from one coordinate reference\n   * system to another. The geometry is modified in place.\n   * For example, a line will be transformed to a line and a circle to a circle.\n   * If you do not want the geometry modified in place, first `clone()` it and\n   * then use this function on the clone.\n   *\n   * @param {import(\"../proj.js\").ProjectionLike} source The current projection.  Can be a\n   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n   * @param {import(\"../proj.js\").ProjectionLike} destination The desired projection.  Can be a\n   *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n   * @return {Geometry} This geometry.  Note that original geometry is\n   *     modified in place.\n   * @api\n   */\n  Geometry.prototype.transform = function transform (source, destination) {\n    /** @type {import(\"../proj/Projection.js\").default} */\n    var sourceProj = getProjection(source);\n    var transformFn = sourceProj.getUnits() == Units.TILE_PIXELS ?\n      function(inCoordinates, outCoordinates, stride) {\n        var pixelExtent = sourceProj.getExtent();\n        var projectedExtent = sourceProj.getWorldExtent();\n        var scale = getHeight(projectedExtent) / getHeight(pixelExtent);\n        composeTransform(tmpTransform,\n          projectedExtent[0], projectedExtent[3],\n          scale, -scale, 0,\n          0, 0);\n        transform2D(inCoordinates, 0, inCoordinates.length, stride,\n          tmpTransform, outCoordinates);\n        return getTransform(sourceProj, destination)(inCoordinates, outCoordinates, stride);\n      } :\n      getTransform(sourceProj, destination);\n    this.applyTransform(transformFn);\n    return this;\n  };\n\n  return Geometry;\n}(BaseObject));\n\n\nexport default Geometry;\n\n//# sourceMappingURL=Geometry.js.map","/**\n * @module ol/geom/flat/closest\n */\nimport {lerp, squaredDistance as squaredDx} from '../../math.js';\n\n\n/**\n * Returns the point on the 2D line segment flatCoordinates[offset1] to\n * flatCoordinates[offset2] that is closest to the point (x, y).  Extra\n * dimensions are linearly interpolated.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset1 Offset 1.\n * @param {number} offset2 Offset 2.\n * @param {number} stride Stride.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n */\nfunction assignClosest(flatCoordinates, offset1, offset2, stride, x, y, closestPoint) {\n  var x1 = flatCoordinates[offset1];\n  var y1 = flatCoordinates[offset1 + 1];\n  var dx = flatCoordinates[offset2] - x1;\n  var dy = flatCoordinates[offset2 + 1] - y1;\n  var offset;\n  if (dx === 0 && dy === 0) {\n    offset = offset1;\n  } else {\n    var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);\n    if (t > 1) {\n      offset = offset2;\n    } else if (t > 0) {\n      for (var i = 0; i < stride; ++i) {\n        closestPoint[i] = lerp(flatCoordinates[offset1 + i],\n          flatCoordinates[offset2 + i], t);\n      }\n      closestPoint.length = stride;\n      return;\n    } else {\n      offset = offset1;\n    }\n  }\n  for (var i$1 = 0; i$1 < stride; ++i$1) {\n    closestPoint[i$1] = flatCoordinates[offset + i$1];\n  }\n  closestPoint.length = stride;\n}\n\n\n/**\n * Return the squared of the largest distance between any pair of consecutive\n * coordinates.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\nexport function maxSquaredDelta(flatCoordinates, offset, end, stride, max) {\n  var x1 = flatCoordinates[offset];\n  var y1 = flatCoordinates[offset + 1];\n  for (offset += stride; offset < end; offset += stride) {\n    var x2 = flatCoordinates[offset];\n    var y2 = flatCoordinates[offset + 1];\n    var squaredDelta = squaredDx(x1, y1, x2, y2);\n    if (squaredDelta > max) {\n      max = squaredDelta;\n    }\n    x1 = x2;\n    y1 = y2;\n  }\n  return max;\n}\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\nexport function arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max) {\n  for (var i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    max = maxSquaredDelta(\n      flatCoordinates, offset, end, stride, max);\n    offset = end;\n  }\n  return max;\n}\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} max Max squared delta.\n * @return {number} Max squared delta.\n */\nexport function multiArrayMaxSquaredDelta(flatCoordinates, offset, endss, stride, max) {\n  for (var i = 0, ii = endss.length; i < ii; ++i) {\n    var ends = endss[i];\n    max = arrayMaxSquaredDelta(\n      flatCoordinates, offset, ends, stride, max);\n    offset = ends[ends.length - 1];\n  }\n  return max;\n}\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array<number>=} opt_tmpPoint Temporary point object.\n * @return {number} Minimum squared distance.\n */\nexport function assignClosestPoint(flatCoordinates, offset, end,\n  stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance,\n  opt_tmpPoint) {\n  if (offset == end) {\n    return minSquaredDistance;\n  }\n  var i, squaredDistance;\n  if (maxDelta === 0) {\n    // All points are identical, so just test the first point.\n    squaredDistance = squaredDx(\n      x, y, flatCoordinates[offset], flatCoordinates[offset + 1]);\n    if (squaredDistance < minSquaredDistance) {\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = flatCoordinates[offset + i];\n      }\n      closestPoint.length = stride;\n      return squaredDistance;\n    } else {\n      return minSquaredDistance;\n    }\n  }\n  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\n  var index = offset + stride;\n  while (index < end) {\n    assignClosest(\n      flatCoordinates, index - stride, index, stride, x, y, tmpPoint);\n    squaredDistance = squaredDx(x, y, tmpPoint[0], tmpPoint[1]);\n    if (squaredDistance < minSquaredDistance) {\n      minSquaredDistance = squaredDistance;\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = tmpPoint[i];\n      }\n      closestPoint.length = stride;\n      index += stride;\n    } else {\n      // Skip ahead multiple points, because we know that all the skipped\n      // points cannot be any closer than the closest point we have found so\n      // far.  We know this because we know how close the current point is, how\n      // close the closest point we have found so far is, and the maximum\n      // distance between consecutive points.  For example, if we're currently\n      // at distance 10, the best we've found so far is 3, and that the maximum\n      // distance between consecutive points is 2, then we'll need to skip at\n      // least (10 - 3) / 2 == 3 (rounded down) points to have any chance of\n      // finding a closer point.  We use Math.max(..., 1) to ensure that we\n      // always advance at least one point, to avoid an infinite loop.\n      index += stride * Math.max(\n        ((Math.sqrt(squaredDistance) -\n            Math.sqrt(minSquaredDistance)) / maxDelta) | 0, 1);\n    }\n  }\n  if (isRing) {\n    // Check the closing segment.\n    assignClosest(\n      flatCoordinates, end - stride, offset, stride, x, y, tmpPoint);\n    squaredDistance = squaredDx(x, y, tmpPoint[0], tmpPoint[1]);\n    if (squaredDistance < minSquaredDistance) {\n      minSquaredDistance = squaredDistance;\n      for (i = 0; i < stride; ++i) {\n        closestPoint[i] = tmpPoint[i];\n      }\n      closestPoint.length = stride;\n    }\n  }\n  return minSquaredDistance;\n}\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array<number>=} opt_tmpPoint Temporary point object.\n * @return {number} Minimum squared distance.\n */\nexport function assignClosestArrayPoint(flatCoordinates, offset, ends,\n  stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance,\n  opt_tmpPoint) {\n  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\n  for (var i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    minSquaredDistance = assignClosestPoint(\n      flatCoordinates, offset, end, stride,\n      maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);\n    offset = end;\n  }\n  return minSquaredDistance;\n}\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {number} maxDelta Max delta.\n * @param {boolean} isRing Is ring.\n * @param {number} x X.\n * @param {number} y Y.\n * @param {Array<number>} closestPoint Closest point.\n * @param {number} minSquaredDistance Minimum squared distance.\n * @param {Array<number>=} opt_tmpPoint Temporary point object.\n * @return {number} Minimum squared distance.\n */\nexport function assignClosestMultiArrayPoint(flatCoordinates, offset,\n  endss, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance,\n  opt_tmpPoint) {\n  var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];\n  for (var i = 0, ii = endss.length; i < ii; ++i) {\n    var ends = endss[i];\n    minSquaredDistance = assignClosestArrayPoint(\n      flatCoordinates, offset, ends, stride,\n      maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);\n    offset = ends[ends.length - 1];\n  }\n  return minSquaredDistance;\n}\n\n//# sourceMappingURL=closest.js.map","/**\n * @module ol/geom/MultiPoint\n */\nimport {extend} from '../array.js';\nimport {closestSquaredDistanceXY, containsXY} from '../extent.js';\nimport GeometryType from './GeometryType.js';\nimport Point from './Point.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {deflateCoordinates} from './flat/deflate.js';\nimport {inflateCoordinates} from './flat/inflate.js';\nimport {squaredDistance as squaredDx} from '../math.js';\n\n/**\n * @classdesc\n * Multi-point geometry.\n *\n * @api\n */\nvar MultiPoint = /*@__PURE__*/(function (SimpleGeometry) {\n  function MultiPoint(coordinates, opt_layout) {\n    SimpleGeometry.call(this);\n    if (opt_layout && !Array.isArray(coordinates[0])) {\n      this.setFlatCoordinates(opt_layout, /** @type {Array<number>} */ (coordinates));\n    } else {\n      this.setCoordinates(/** @type {Array<import(\"../coordinate.js\").Coordinate>} */ (coordinates), opt_layout);\n    }\n  }\n\n  if ( SimpleGeometry ) MultiPoint.__proto__ = SimpleGeometry;\n  MultiPoint.prototype = Object.create( SimpleGeometry && SimpleGeometry.prototype );\n  MultiPoint.prototype.constructor = MultiPoint;\n\n  /**\n   * Append the passed point to this multipoint.\n   * @param {Point} point Point.\n   * @api\n   */\n  MultiPoint.prototype.appendPoint = function appendPoint (point) {\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = point.getFlatCoordinates().slice();\n    } else {\n      extend(this.flatCoordinates, point.getFlatCoordinates());\n    }\n    this.changed();\n  };\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!MultiPoint} Clone.\n   * @override\n   * @api\n   */\n  MultiPoint.prototype.clone = function clone () {\n    var multiPoint = new MultiPoint(this.flatCoordinates.slice(), this.layout);\n    return multiPoint;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  MultiPoint.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    var flatCoordinates = this.flatCoordinates;\n    var stride = this.stride;\n    for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n      var squaredDistance = squaredDx(\n        x, y, flatCoordinates[i], flatCoordinates[i + 1]);\n      if (squaredDistance < minSquaredDistance) {\n        minSquaredDistance = squaredDistance;\n        for (var j = 0; j < stride; ++j) {\n          closestPoint[j] = flatCoordinates[i + j];\n        }\n        closestPoint.length = stride;\n      }\n    }\n    return minSquaredDistance;\n  };\n\n  /**\n   * Return the coordinates of the multipoint.\n   * @return {Array<import(\"../coordinate.js\").Coordinate>} Coordinates.\n   * @override\n   * @api\n   */\n  MultiPoint.prototype.getCoordinates = function getCoordinates () {\n    return inflateCoordinates(\n      this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);\n  };\n\n  /**\n   * Return the point at the specified index.\n   * @param {number} index Index.\n   * @return {Point} Point.\n   * @api\n   */\n  MultiPoint.prototype.getPoint = function getPoint (index) {\n    var n = !this.flatCoordinates ? 0 : this.flatCoordinates.length / this.stride;\n    if (index < 0 || n <= index) {\n      return null;\n    }\n    return new Point(this.flatCoordinates.slice(\n      index * this.stride, (index + 1) * this.stride), this.layout);\n  };\n\n  /**\n   * Return the points of this multipoint.\n   * @return {Array<Point>} Points.\n   * @api\n   */\n  MultiPoint.prototype.getPoints = function getPoints () {\n    var flatCoordinates = this.flatCoordinates;\n    var layout = this.layout;\n    var stride = this.stride;\n    /** @type {Array<Point>} */\n    var points = [];\n    for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n      var point = new Point(flatCoordinates.slice(i, i + stride), layout);\n      points.push(point);\n    }\n    return points;\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  MultiPoint.prototype.getType = function getType () {\n    return GeometryType.MULTI_POINT;\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  MultiPoint.prototype.intersectsExtent = function intersectsExtent (extent) {\n    var flatCoordinates = this.flatCoordinates;\n    var stride = this.stride;\n    for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {\n      var x = flatCoordinates[i];\n      var y = flatCoordinates[i + 1];\n      if (containsXY(extent, x, y)) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  /**\n   * Set the coordinates of the multipoint.\n   * @param {!Array<import(\"../coordinate.js\").Coordinate>} coordinates Coordinates.\n   * @param {import(\"./GeometryLayout.js\").default=} opt_layout Layout.\n   * @override\n   * @api\n   */\n  MultiPoint.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {\n    this.setLayout(opt_layout, coordinates, 1);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    this.flatCoordinates.length = deflateCoordinates(\n      this.flatCoordinates, 0, coordinates, this.stride);\n    this.changed();\n  };\n\n  return MultiPoint;\n}(SimpleGeometry));\n\n\nexport default MultiPoint;\n\n//# sourceMappingURL=MultiPoint.js.map","/**\n * @module ol/geom/SimpleGeometry\n */\nimport {abstract} from '../util.js';\nimport {createOrUpdateFromFlatCoordinates, getCenter} from '../extent.js';\nimport Geometry from './Geometry.js';\nimport GeometryLayout from './GeometryLayout.js';\nimport {rotate, scale, translate, transform2D} from './flat/transform.js';\nimport {clear} from '../obj.js';\n\n/**\n * @classdesc\n * Abstract base class; only used for creating subclasses; do not instantiate\n * in apps, as cannot be rendered.\n *\n * @abstract\n * @api\n */\nvar SimpleGeometry = /*@__PURE__*/(function (Geometry) {\n  function SimpleGeometry() {\n\n    Geometry.call(this);\n\n    /**\n     * @protected\n     * @type {GeometryLayout}\n     */\n    this.layout = GeometryLayout.XY;\n\n    /**\n     * @protected\n     * @type {number}\n     */\n    this.stride = 2;\n\n    /**\n     * @protected\n     * @type {Array<number>}\n     */\n    this.flatCoordinates = null;\n\n  }\n\n  if ( Geometry ) SimpleGeometry.__proto__ = Geometry;\n  SimpleGeometry.prototype = Object.create( Geometry && Geometry.prototype );\n  SimpleGeometry.prototype.constructor = SimpleGeometry;\n\n  /**\n   * @inheritDoc\n   */\n  SimpleGeometry.prototype.computeExtent = function computeExtent (extent) {\n    return createOrUpdateFromFlatCoordinates(this.flatCoordinates,\n      0, this.flatCoordinates.length, this.stride, extent);\n  };\n\n  /**\n   * @abstract\n   * @return {Array} Coordinates.\n   */\n  SimpleGeometry.prototype.getCoordinates = function getCoordinates () {\n    return abstract();\n  };\n\n  /**\n   * Return the first coordinate of the geometry.\n   * @return {import(\"../coordinate.js\").Coordinate} First coordinate.\n   * @api\n   */\n  SimpleGeometry.prototype.getFirstCoordinate = function getFirstCoordinate () {\n    return this.flatCoordinates.slice(0, this.stride);\n  };\n\n  /**\n   * @return {Array<number>} Flat coordinates.\n   */\n  SimpleGeometry.prototype.getFlatCoordinates = function getFlatCoordinates () {\n    return this.flatCoordinates;\n  };\n\n  /**\n   * Return the last coordinate of the geometry.\n   * @return {import(\"../coordinate.js\").Coordinate} Last point.\n   * @api\n   */\n  SimpleGeometry.prototype.getLastCoordinate = function getLastCoordinate () {\n    return this.flatCoordinates.slice(this.flatCoordinates.length - this.stride);\n  };\n\n  /**\n   * Return the {@link module:ol/geom/GeometryLayout layout} of the geometry.\n   * @return {GeometryLayout} Layout.\n   * @api\n   */\n  SimpleGeometry.prototype.getLayout = function getLayout () {\n    return this.layout;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  SimpleGeometry.prototype.getSimplifiedGeometry = function getSimplifiedGeometry (squaredTolerance) {\n    if (this.simplifiedGeometryRevision != this.getRevision()) {\n      clear(this.simplifiedGeometryCache);\n      this.simplifiedGeometryMaxMinSquaredTolerance = 0;\n      this.simplifiedGeometryRevision = this.getRevision();\n    }\n    // If squaredTolerance is negative or if we know that simplification will not\n    // have any effect then just return this.\n    if (squaredTolerance < 0 ||\n        (this.simplifiedGeometryMaxMinSquaredTolerance !== 0 &&\n         squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance)) {\n      return this;\n    }\n    var key = squaredTolerance.toString();\n    if (this.simplifiedGeometryCache.hasOwnProperty(key)) {\n      return this.simplifiedGeometryCache[key];\n    } else {\n      var simplifiedGeometry =\n          this.getSimplifiedGeometryInternal(squaredTolerance);\n      var simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();\n      if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {\n        this.simplifiedGeometryCache[key] = simplifiedGeometry;\n        return simplifiedGeometry;\n      } else {\n        // Simplification did not actually remove any coordinates.  We now know\n        // that any calls to getSimplifiedGeometry with a squaredTolerance less\n        // than or equal to the current squaredTolerance will also not have any\n        // effect.  This allows us to short circuit simplification (saving CPU\n        // cycles) and prevents the cache of simplified geometries from filling\n        // up with useless identical copies of this geometry (saving memory).\n        this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;\n        return this;\n      }\n    }\n  };\n\n  /**\n   * @param {number} squaredTolerance Squared tolerance.\n   * @return {SimpleGeometry} Simplified geometry.\n   * @protected\n   */\n  SimpleGeometry.prototype.getSimplifiedGeometryInternal = function getSimplifiedGeometryInternal (squaredTolerance) {\n    return this;\n  };\n\n  /**\n   * @return {number} Stride.\n   */\n  SimpleGeometry.prototype.getStride = function getStride () {\n    return this.stride;\n  };\n\n  /**\n   * @param {GeometryLayout} layout Layout.\n   * @param {Array<number>} flatCoordinates Flat coordinates.\n   */\n  SimpleGeometry.prototype.setFlatCoordinates = function setFlatCoordinates (layout, flatCoordinates) {\n    this.stride = getStrideForLayout(layout);\n    this.layout = layout;\n    this.flatCoordinates = flatCoordinates;\n  };\n\n  /**\n   * @abstract\n   * @param {!Array} coordinates Coordinates.\n   * @param {GeometryLayout=} opt_layout Layout.\n   */\n  SimpleGeometry.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {\n    abstract();\n  };\n\n  /**\n   * @param {GeometryLayout|undefined} layout Layout.\n   * @param {Array} coordinates Coordinates.\n   * @param {number} nesting Nesting.\n   * @protected\n   */\n  SimpleGeometry.prototype.setLayout = function setLayout (layout, coordinates, nesting) {\n    /** @type {number} */\n    var stride;\n    if (layout) {\n      stride = getStrideForLayout(layout);\n    } else {\n      for (var i = 0; i < nesting; ++i) {\n        if (coordinates.length === 0) {\n          this.layout = GeometryLayout.XY;\n          this.stride = 2;\n          return;\n        } else {\n          coordinates = /** @type {Array} */ (coordinates[0]);\n        }\n      }\n      stride = coordinates.length;\n      layout = getLayoutForStride(stride);\n    }\n    this.layout = layout;\n    this.stride = stride;\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  SimpleGeometry.prototype.applyTransform = function applyTransform (transformFn) {\n    if (this.flatCoordinates) {\n      transformFn(this.flatCoordinates, this.flatCoordinates, this.stride);\n      this.changed();\n    }\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  SimpleGeometry.prototype.rotate = function rotate$1 (angle, anchor) {\n    var flatCoordinates = this.getFlatCoordinates();\n    if (flatCoordinates) {\n      var stride = this.getStride();\n      rotate(\n        flatCoordinates, 0, flatCoordinates.length,\n        stride, angle, anchor, flatCoordinates);\n      this.changed();\n    }\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  SimpleGeometry.prototype.scale = function scale$1 (sx, opt_sy, opt_anchor) {\n    var sy = opt_sy;\n    if (sy === undefined) {\n      sy = sx;\n    }\n    var anchor = opt_anchor;\n    if (!anchor) {\n      anchor = getCenter(this.getExtent());\n    }\n    var flatCoordinates = this.getFlatCoordinates();\n    if (flatCoordinates) {\n      var stride = this.getStride();\n      scale(\n        flatCoordinates, 0, flatCoordinates.length,\n        stride, sx, sy, anchor, flatCoordinates);\n      this.changed();\n    }\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  SimpleGeometry.prototype.translate = function translate$1 (deltaX, deltaY) {\n    var flatCoordinates = this.getFlatCoordinates();\n    if (flatCoordinates) {\n      var stride = this.getStride();\n      translate(\n        flatCoordinates, 0, flatCoordinates.length, stride,\n        deltaX, deltaY, flatCoordinates);\n      this.changed();\n    }\n  };\n\n  return SimpleGeometry;\n}(Geometry));\n\n\n/**\n * @param {number} stride Stride.\n * @return {GeometryLayout} layout Layout.\n */\nfunction getLayoutForStride(stride) {\n  var layout;\n  if (stride == 2) {\n    layout = GeometryLayout.XY;\n  } else if (stride == 3) {\n    layout = GeometryLayout.XYZ;\n  } else if (stride == 4) {\n    layout = GeometryLayout.XYZM;\n  }\n  return (\n    /** @type {GeometryLayout} */ (layout)\n  );\n}\n\n\n/**\n * @param {GeometryLayout} layout Layout.\n * @return {number} Stride.\n */\nexport function getStrideForLayout(layout) {\n  var stride;\n  if (layout == GeometryLayout.XY) {\n    stride = 2;\n  } else if (layout == GeometryLayout.XYZ || layout == GeometryLayout.XYM) {\n    stride = 3;\n  } else if (layout == GeometryLayout.XYZM) {\n    stride = 4;\n  }\n  return /** @type {number} */ (stride);\n}\n\n\n/**\n * @param {SimpleGeometry} simpleGeometry Simple geometry.\n * @param {import(\"../transform.js\").Transform} transform Transform.\n * @param {Array<number>=} opt_dest Destination.\n * @return {Array<number>} Transformed flat coordinates.\n */\nexport function transformGeom2D(simpleGeometry, transform, opt_dest) {\n  var flatCoordinates = simpleGeometry.getFlatCoordinates();\n  if (!flatCoordinates) {\n    return null;\n  } else {\n    var stride = simpleGeometry.getStride();\n    return transform2D(\n      flatCoordinates, 0, flatCoordinates.length, stride,\n      transform, opt_dest);\n  }\n}\n\nexport default SimpleGeometry;\n\n//# sourceMappingURL=SimpleGeometry.js.map","/**\n * @module ol/geom/flat/deflate\n */\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {import(\"../../coordinate.js\").Coordinate} coordinate Coordinate.\n * @param {number} stride Stride.\n * @return {number} offset Offset.\n */\nexport function deflateCoordinate(flatCoordinates, offset, coordinate, stride) {\n  for (var i = 0, ii = coordinate.length; i < ii; ++i) {\n    flatCoordinates[offset++] = coordinate[i];\n  }\n  return offset;\n}\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<import(\"../../coordinate.js\").Coordinate>} coordinates Coordinates.\n * @param {number} stride Stride.\n * @return {number} offset Offset.\n */\nexport function deflateCoordinates(flatCoordinates, offset, coordinates, stride) {\n  for (var i = 0, ii = coordinates.length; i < ii; ++i) {\n    var coordinate = coordinates[i];\n    for (var j = 0; j < stride; ++j) {\n      flatCoordinates[offset++] = coordinate[j];\n    }\n  }\n  return offset;\n}\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<import(\"../../coordinate.js\").Coordinate>>} coordinatess Coordinatess.\n * @param {number} stride Stride.\n * @param {Array<number>=} opt_ends Ends.\n * @return {Array<number>} Ends.\n */\nexport function deflateCoordinatesArray(flatCoordinates, offset, coordinatess, stride, opt_ends) {\n  var ends = opt_ends ? opt_ends : [];\n  var i = 0;\n  for (var j = 0, jj = coordinatess.length; j < jj; ++j) {\n    var end = deflateCoordinates(\n      flatCoordinates, offset, coordinatess[j], stride);\n    ends[i++] = end;\n    offset = end;\n  }\n  ends.length = i;\n  return ends;\n}\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<Array<import(\"../../coordinate.js\").Coordinate>>>} coordinatesss Coordinatesss.\n * @param {number} stride Stride.\n * @param {Array<Array<number>>=} opt_endss Endss.\n * @return {Array<Array<number>>} Endss.\n */\nexport function deflateMultiCoordinatesArray(flatCoordinates, offset, coordinatesss, stride, opt_endss) {\n  var endss = opt_endss ? opt_endss : [];\n  var i = 0;\n  for (var j = 0, jj = coordinatesss.length; j < jj; ++j) {\n    var ends = deflateCoordinatesArray(\n      flatCoordinates, offset, coordinatesss[j], stride, endss[i]);\n    endss[i++] = ends;\n    offset = ends[ends.length - 1];\n  }\n  endss.length = i;\n  return endss;\n}\n\n//# sourceMappingURL=deflate.js.map","/**\n * @module ol/geom/flat/interpolate\n */\nimport {binarySearch} from '../../array.js';\nimport {lerp} from '../../math.js';\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} fraction Fraction.\n * @param {Array<number>=} opt_dest Destination.\n * @return {Array<number>} Destination.\n */\nexport function interpolatePoint(flatCoordinates, offset, end, stride, fraction, opt_dest) {\n  var pointX = NaN;\n  var pointY = NaN;\n  var n = (end - offset) / stride;\n  if (n === 1) {\n    pointX = flatCoordinates[offset];\n    pointY = flatCoordinates[offset + 1];\n  } else if (n == 2) {\n    pointX = (1 - fraction) * flatCoordinates[offset] +\n        fraction * flatCoordinates[offset + stride];\n    pointY = (1 - fraction) * flatCoordinates[offset + 1] +\n        fraction * flatCoordinates[offset + stride + 1];\n  } else if (n !== 0) {\n    var x1 = flatCoordinates[offset];\n    var y1 = flatCoordinates[offset + 1];\n    var length = 0;\n    var cumulativeLengths = [0];\n    for (var i = offset + stride; i < end; i += stride) {\n      var x2 = flatCoordinates[i];\n      var y2 = flatCoordinates[i + 1];\n      length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n      cumulativeLengths.push(length);\n      x1 = x2;\n      y1 = y2;\n    }\n    var target = fraction * length;\n    var index = binarySearch(cumulativeLengths, target);\n    if (index < 0) {\n      var t = (target - cumulativeLengths[-index - 2]) /\n          (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);\n      var o = offset + (-index - 2) * stride;\n      pointX = lerp(\n        flatCoordinates[o], flatCoordinates[o + stride], t);\n      pointY = lerp(\n        flatCoordinates[o + 1], flatCoordinates[o + stride + 1], t);\n    } else {\n      pointX = flatCoordinates[offset + index * stride];\n      pointY = flatCoordinates[offset + index * stride + 1];\n    }\n  }\n  if (opt_dest) {\n    opt_dest[0] = pointX;\n    opt_dest[1] = pointY;\n    return opt_dest;\n  } else {\n    return [pointX, pointY];\n  }\n}\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} m M.\n * @param {boolean} extrapolate Extrapolate.\n * @return {import(\"../../coordinate.js\").Coordinate} Coordinate.\n */\nexport function lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, extrapolate) {\n  if (end == offset) {\n    return null;\n  }\n  var coordinate;\n  if (m < flatCoordinates[offset + stride - 1]) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(offset, offset + stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  } else if (flatCoordinates[end - 1] < m) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(end - stride, end);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  }\n  // FIXME use O(1) search\n  if (m == flatCoordinates[offset + stride - 1]) {\n    return flatCoordinates.slice(offset, offset + stride);\n  }\n  var lo = offset / stride;\n  var hi = end / stride;\n  while (lo < hi) {\n    var mid = (lo + hi) >> 1;\n    if (m < flatCoordinates[(mid + 1) * stride - 1]) {\n      hi = mid;\n    } else {\n      lo = mid + 1;\n    }\n  }\n  var m0 = flatCoordinates[lo * stride - 1];\n  if (m == m0) {\n    return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);\n  }\n  var m1 = flatCoordinates[(lo + 1) * stride - 1];\n  var t = (m - m0) / (m1 - m0);\n  coordinate = [];\n  for (var i = 0; i < stride - 1; ++i) {\n    coordinate.push(lerp(flatCoordinates[(lo - 1) * stride + i],\n      flatCoordinates[lo * stride + i], t));\n  }\n  coordinate.push(m);\n  return coordinate;\n}\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {number} m M.\n * @param {boolean} extrapolate Extrapolate.\n * @param {boolean} interpolate Interpolate.\n * @return {import(\"../../coordinate.js\").Coordinate} Coordinate.\n */\nexport function lineStringsCoordinateAtM(\n  flatCoordinates, offset, ends, stride, m, extrapolate, interpolate) {\n  if (interpolate) {\n    return lineStringCoordinateAtM(\n      flatCoordinates, offset, ends[ends.length - 1], stride, m, extrapolate);\n  }\n  var coordinate;\n  if (m < flatCoordinates[stride - 1]) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(0, stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  }\n  if (flatCoordinates[flatCoordinates.length - 1] < m) {\n    if (extrapolate) {\n      coordinate = flatCoordinates.slice(flatCoordinates.length - stride);\n      coordinate[stride - 1] = m;\n      return coordinate;\n    } else {\n      return null;\n    }\n  }\n  for (var i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    if (offset == end) {\n      continue;\n    }\n    if (m < flatCoordinates[offset + stride - 1]) {\n      return null;\n    } else if (m <= flatCoordinates[end - 1]) {\n      return lineStringCoordinateAtM(\n        flatCoordinates, offset, end, stride, m, false);\n    }\n    offset = end;\n  }\n  return null;\n}\n\n//# sourceMappingURL=interpolate.js.map","/**\n * @module ol/geom/flat/area\n */\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @return {number} Area.\n */\nexport function linearRing(flatCoordinates, offset, end, stride) {\n  var twiceArea = 0;\n  var x1 = flatCoordinates[end - stride];\n  var y1 = flatCoordinates[end - stride + 1];\n  for (; offset < end; offset += stride) {\n    var x2 = flatCoordinates[offset];\n    var y2 = flatCoordinates[offset + 1];\n    twiceArea += y1 * x2 - x1 * y2;\n    x1 = x2;\n    y1 = y2;\n  }\n  return twiceArea / 2;\n}\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @return {number} Area.\n */\nexport function linearRings(flatCoordinates, offset, ends, stride) {\n  var area = 0;\n  for (var i = 0, ii = ends.length; i < ii; ++i) {\n    var end = ends[i];\n    area += linearRing(flatCoordinates, offset, end, stride);\n    offset = end;\n  }\n  return area;\n}\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @return {number} Area.\n */\nexport function linearRingss(flatCoordinates, offset, endss, stride) {\n  var area = 0;\n  for (var i = 0, ii = endss.length; i < ii; ++i) {\n    var ends = endss[i];\n    area += linearRings(flatCoordinates, offset, ends, stride);\n    offset = ends[ends.length - 1];\n  }\n  return area;\n}\n\n//# sourceMappingURL=area.js.map","/**\n * @module ol/geom/flat/inflate\n */\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {Array<import(\"../../coordinate.js\").Coordinate>=} opt_coordinates Coordinates.\n * @return {Array<import(\"../../coordinate.js\").Coordinate>} Coordinates.\n */\nexport function inflateCoordinates(flatCoordinates, offset, end, stride, opt_coordinates) {\n  var coordinates = opt_coordinates !== undefined ? opt_coordinates : [];\n  var i = 0;\n  for (var j = offset; j < end; j += stride) {\n    coordinates[i++] = flatCoordinates.slice(j, j + stride);\n  }\n  coordinates.length = i;\n  return coordinates;\n}\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {Array<Array<import(\"../../coordinate.js\").Coordinate>>=} opt_coordinatess Coordinatess.\n * @return {Array<Array<import(\"../../coordinate.js\").Coordinate>>} Coordinatess.\n */\nexport function inflateCoordinatesArray(flatCoordinates, offset, ends, stride, opt_coordinatess) {\n  var coordinatess = opt_coordinatess !== undefined ? opt_coordinatess : [];\n  var i = 0;\n  for (var j = 0, jj = ends.length; j < jj; ++j) {\n    var end = ends[j];\n    coordinatess[i++] = inflateCoordinates(\n      flatCoordinates, offset, end, stride, coordinatess[i]);\n    offset = end;\n  }\n  coordinatess.length = i;\n  return coordinatess;\n}\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {Array<Array<Array<import(\"../../coordinate.js\").Coordinate>>>=} opt_coordinatesss\n *     Coordinatesss.\n * @return {Array<Array<Array<import(\"../../coordinate.js\").Coordinate>>>} Coordinatesss.\n */\nexport function inflateMultiCoordinatesArray(flatCoordinates, offset, endss, stride, opt_coordinatesss) {\n  var coordinatesss = opt_coordinatesss !== undefined ? opt_coordinatesss : [];\n  var i = 0;\n  for (var j = 0, jj = endss.length; j < jj; ++j) {\n    var ends = endss[j];\n    coordinatesss[i++] = inflateCoordinatesArray(\n      flatCoordinates, offset, ends, stride, coordinatesss[i]);\n    offset = ends[ends.length - 1];\n  }\n  coordinatesss.length = i;\n  return coordinatesss;\n}\n\n//# sourceMappingURL=inflate.js.map","/**\n * @module ol/geom/flat/transform\n */\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import(\"../../transform.js\").Transform} transform Transform.\n * @param {Array<number>=} opt_dest Destination.\n * @return {Array<number>} Transformed coordinates.\n */\nexport function transform2D(flatCoordinates, offset, end, stride, transform, opt_dest) {\n  var dest = opt_dest ? opt_dest : [];\n  var i = 0;\n  for (var j = offset; j < end; j += stride) {\n    var x = flatCoordinates[j];\n    var y = flatCoordinates[j + 1];\n    dest[i++] = transform[0] * x + transform[2] * y + transform[4];\n    dest[i++] = transform[1] * x + transform[3] * y + transform[5];\n  }\n  if (opt_dest && dest.length != i) {\n    dest.length = i;\n  }\n  return dest;\n}\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} angle Angle.\n * @param {Array<number>} anchor Rotation anchor point.\n * @param {Array<number>=} opt_dest Destination.\n * @return {Array<number>} Transformed coordinates.\n */\nexport function rotate(flatCoordinates, offset, end, stride, angle, anchor, opt_dest) {\n  var dest = opt_dest ? opt_dest : [];\n  var cos = Math.cos(angle);\n  var sin = Math.sin(angle);\n  var anchorX = anchor[0];\n  var anchorY = anchor[1];\n  var i = 0;\n  for (var j = offset; j < end; j += stride) {\n    var deltaX = flatCoordinates[j] - anchorX;\n    var deltaY = flatCoordinates[j + 1] - anchorY;\n    dest[i++] = anchorX + deltaX * cos - deltaY * sin;\n    dest[i++] = anchorY + deltaX * sin + deltaY * cos;\n    for (var k = j + 2; k < j + stride; ++k) {\n      dest[i++] = flatCoordinates[k];\n    }\n  }\n  if (opt_dest && dest.length != i) {\n    dest.length = i;\n  }\n  return dest;\n}\n\n\n/**\n * Scale the coordinates.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} sx Scale factor in the x-direction.\n * @param {number} sy Scale factor in the y-direction.\n * @param {Array<number>} anchor Scale anchor point.\n * @param {Array<number>=} opt_dest Destination.\n * @return {Array<number>} Transformed coordinates.\n */\nexport function scale(flatCoordinates, offset, end, stride, sx, sy, anchor, opt_dest) {\n  var dest = opt_dest ? opt_dest : [];\n  var anchorX = anchor[0];\n  var anchorY = anchor[1];\n  var i = 0;\n  for (var j = offset; j < end; j += stride) {\n    var deltaX = flatCoordinates[j] - anchorX;\n    var deltaY = flatCoordinates[j + 1] - anchorY;\n    dest[i++] = anchorX + sx * deltaX;\n    dest[i++] = anchorY + sy * deltaY;\n    for (var k = j + 2; k < j + stride; ++k) {\n      dest[i++] = flatCoordinates[k];\n    }\n  }\n  if (opt_dest && dest.length != i) {\n    dest.length = i;\n  }\n  return dest;\n}\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {number} deltaX Delta X.\n * @param {number} deltaY Delta Y.\n * @param {Array<number>=} opt_dest Destination.\n * @return {Array<number>} Transformed coordinates.\n */\nexport function translate(flatCoordinates, offset, end, stride, deltaX, deltaY, opt_dest) {\n  var dest = opt_dest ? opt_dest : [];\n  var i = 0;\n  for (var j = offset; j < end; j += stride) {\n    dest[i++] = flatCoordinates[j] + deltaX;\n    dest[i++] = flatCoordinates[j + 1] + deltaY;\n    for (var k = j + 2; k < j + stride; ++k) {\n      dest[i++] = flatCoordinates[k];\n    }\n  }\n  if (opt_dest && dest.length != i) {\n    dest.length = i;\n  }\n  return dest;\n}\n\n//# sourceMappingURL=transform.js.map","/**\n * @module ol/geom/flat/intersectsextent\n */\nimport {containsExtent, createEmpty, extendFlatCoordinates, intersects, intersectsSegment} from '../../extent.js';\nimport {linearRingContainsXY, linearRingContainsExtent} from './contains.js';\nimport {forEach as forEachSegment} from './segments.js';\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLineString(flatCoordinates, offset, end, stride, extent) {\n  var coordinatesExtent = extendFlatCoordinates(\n    createEmpty(), flatCoordinates, offset, end, stride);\n  if (!intersects(extent, coordinatesExtent)) {\n    return false;\n  }\n  if (containsExtent(extent, coordinatesExtent)) {\n    return true;\n  }\n  if (coordinatesExtent[0] >= extent[0] &&\n      coordinatesExtent[2] <= extent[2]) {\n    return true;\n  }\n  if (coordinatesExtent[1] >= extent[1] &&\n      coordinatesExtent[3] <= extent[3]) {\n    return true;\n  }\n  return forEachSegment(flatCoordinates, offset, end, stride,\n    /**\n     * @param {import(\"../../coordinate.js\").Coordinate} point1 Start point.\n     * @param {import(\"../../coordinate.js\").Coordinate} point2 End point.\n     * @return {boolean} `true` if the segment and the extent intersect,\n     *     `false` otherwise.\n     */\n    function(point1, point2) {\n      return intersectsSegment(extent, point1, point2);\n    });\n}\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLineStringArray(flatCoordinates, offset, ends, stride, extent) {\n  for (var i = 0, ii = ends.length; i < ii; ++i) {\n    if (intersectsLineString(\n      flatCoordinates, offset, ends[i], stride, extent)) {\n      return true;\n    }\n    offset = ends[i];\n  }\n  return false;\n}\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLinearRing(flatCoordinates, offset, end, stride, extent) {\n  if (intersectsLineString(\n    flatCoordinates, offset, end, stride, extent)) {\n    return true;\n  }\n  if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[0], extent[1])) {\n    return true;\n  }\n  if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[0], extent[3])) {\n    return true;\n  }\n  if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[2], extent[1])) {\n    return true;\n  }\n  if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[2], extent[3])) {\n    return true;\n  }\n  return false;\n}\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<number>} ends Ends.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent) {\n  if (!intersectsLinearRing(\n    flatCoordinates, offset, ends[0], stride, extent)) {\n    return false;\n  }\n  if (ends.length === 1) {\n    return true;\n  }\n  for (var i = 1, ii = ends.length; i < ii; ++i) {\n    if (linearRingContainsExtent(flatCoordinates, ends[i - 1], ends[i], stride, extent)) {\n      if (!intersectsLineString(flatCoordinates, ends[i - 1], ends[i], stride, extent)) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n\n/**\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {Array<Array<number>>} endss Endss.\n * @param {number} stride Stride.\n * @param {import(\"../../extent.js\").Extent} extent Extent.\n * @return {boolean} True if the geometry and the extent intersect.\n */\nexport function intersectsLinearRingMultiArray(flatCoordinates, offset, endss, stride, extent) {\n  for (var i = 0, ii = endss.length; i < ii; ++i) {\n    var ends = endss[i];\n    if (intersectsLinearRingArray(\n      flatCoordinates, offset, ends, stride, extent)) {\n      return true;\n    }\n    offset = ends[ends.length - 1];\n  }\n  return false;\n}\n\n//# sourceMappingURL=intersectsextent.js.map","/**\n * @module ol/geom/GeometryCollection\n */\nimport {listen, unlisten} from '../events.js';\nimport EventType from '../events/EventType.js';\nimport {createOrUpdateEmpty, closestSquaredDistanceXY, extend, getCenter} from '../extent.js';\nimport Geometry from './Geometry.js';\nimport GeometryType from './GeometryType.js';\nimport {clear} from '../obj.js';\n\n/**\n * @classdesc\n * An array of {@link module:ol/geom/Geometry} objects.\n *\n * @api\n */\nvar GeometryCollection = /*@__PURE__*/(function (Geometry) {\n  function GeometryCollection(opt_geometries) {\n\n    Geometry.call(this);\n\n    /**\n     * @private\n     * @type {Array<Geometry>}\n     */\n    this.geometries_ = opt_geometries ? opt_geometries : null;\n\n    this.listenGeometriesChange_();\n  }\n\n  if ( Geometry ) GeometryCollection.__proto__ = Geometry;\n  GeometryCollection.prototype = Object.create( Geometry && Geometry.prototype );\n  GeometryCollection.prototype.constructor = GeometryCollection;\n\n  /**\n   * @private\n   */\n  GeometryCollection.prototype.unlistenGeometriesChange_ = function unlistenGeometriesChange_ () {\n    if (!this.geometries_) {\n      return;\n    }\n    for (var i = 0, ii = this.geometries_.length; i < ii; ++i) {\n      unlisten(\n        this.geometries_[i], EventType.CHANGE,\n        this.changed, this);\n    }\n  };\n\n  /**\n   * @private\n   */\n  GeometryCollection.prototype.listenGeometriesChange_ = function listenGeometriesChange_ () {\n    if (!this.geometries_) {\n      return;\n    }\n    for (var i = 0, ii = this.geometries_.length; i < ii; ++i) {\n      listen(\n        this.geometries_[i], EventType.CHANGE,\n        this.changed, this);\n    }\n  };\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!GeometryCollection} Clone.\n   * @override\n   * @api\n   */\n  GeometryCollection.prototype.clone = function clone () {\n    var geometryCollection = new GeometryCollection(null);\n    geometryCollection.setGeometries(this.geometries_);\n    return geometryCollection;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  GeometryCollection.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {\n    if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {\n      return minSquaredDistance;\n    }\n    var geometries = this.geometries_;\n    for (var i = 0, ii = geometries.length; i < ii; ++i) {\n      minSquaredDistance = geometries[i].closestPointXY(\n        x, y, closestPoint, minSquaredDistance);\n    }\n    return minSquaredDistance;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  GeometryCollection.prototype.containsXY = function containsXY (x, y) {\n    var geometries = this.geometries_;\n    for (var i = 0, ii = geometries.length; i < ii; ++i) {\n      if (geometries[i].containsXY(x, y)) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  GeometryCollection.prototype.computeExtent = function computeExtent (extent) {\n    createOrUpdateEmpty(extent);\n    var geometries = this.geometries_;\n    for (var i = 0, ii = geometries.length; i < ii; ++i) {\n      extend(extent, geometries[i].getExtent());\n    }\n    return extent;\n  };\n\n  /**\n   * Return the geometries that make up this geometry collection.\n   * @return {Array<Geometry>} Geometries.\n   * @api\n   */\n  GeometryCollection.prototype.getGeometries = function getGeometries () {\n    return cloneGeometries(this.geometries_);\n  };\n\n  /**\n   * @return {Array<Geometry>} Geometries.\n   */\n  GeometryCollection.prototype.getGeometriesArray = function getGeometriesArray () {\n    return this.geometries_;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  GeometryCollection.prototype.getSimplifiedGeometry = function getSimplifiedGeometry (squaredTolerance) {\n    if (this.simplifiedGeometryRevision != this.getRevision()) {\n      clear(this.simplifiedGeometryCache);\n      this.simplifiedGeometryMaxMinSquaredTolerance = 0;\n      this.simplifiedGeometryRevision = this.getRevision();\n    }\n    if (squaredTolerance < 0 ||\n        (this.simplifiedGeometryMaxMinSquaredTolerance !== 0 &&\n         squaredTolerance < this.simplifiedGeometryMaxMinSquaredTolerance)) {\n      return this;\n    }\n    var key = squaredTolerance.toString();\n    if (this.simplifiedGeometryCache.hasOwnProperty(key)) {\n      return this.simplifiedGeometryCache[key];\n    } else {\n      var simplifiedGeometries = [];\n      var geometries = this.geometries_;\n      var simplified = false;\n      for (var i = 0, ii = geometries.length; i < ii; ++i) {\n        var geometry = geometries[i];\n        var simplifiedGeometry = geometry.getSimplifiedGeometry(squaredTolerance);\n        simplifiedGeometries.push(simplifiedGeometry);\n        if (simplifiedGeometry !== geometry) {\n          simplified = true;\n        }\n      }\n      if (simplified) {\n        var simplifiedGeometryCollection = new GeometryCollection(null);\n        simplifiedGeometryCollection.setGeometriesArray(simplifiedGeometries);\n        this.simplifiedGeometryCache[key] = simplifiedGeometryCollection;\n        return simplifiedGeometryCollection;\n      } else {\n        this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;\n        return this;\n      }\n    }\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  GeometryCollection.prototype.getType = function getType () {\n    return GeometryType.GEOMETRY_COLLECTION;\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  GeometryCollection.prototype.intersectsExtent = function intersectsExtent (extent) {\n    var geometries = this.geometries_;\n    for (var i = 0, ii = geometries.length; i < ii; ++i) {\n      if (geometries[i].intersectsExtent(extent)) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  /**\n   * @return {boolean} Is empty.\n   */\n  GeometryCollection.prototype.isEmpty = function isEmpty () {\n    return this.geometries_.length === 0;\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  GeometryCollection.prototype.rotate = function rotate (angle, anchor) {\n    var geometries = this.geometries_;\n    for (var i = 0, ii = geometries.length; i < ii; ++i) {\n      geometries[i].rotate(angle, anchor);\n    }\n    this.changed();\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  GeometryCollection.prototype.scale = function scale (sx, opt_sy, opt_anchor) {\n    var anchor = opt_anchor;\n    if (!anchor) {\n      anchor = getCenter(this.getExtent());\n    }\n    var geometries = this.geometries_;\n    for (var i = 0, ii = geometries.length; i < ii; ++i) {\n      geometries[i].scale(sx, opt_sy, anchor);\n    }\n    this.changed();\n  };\n\n  /**\n   * Set the geometries that make up this geometry collection.\n   * @param {Array<Geometry>} geometries Geometries.\n   * @api\n   */\n  GeometryCollection.prototype.setGeometries = function setGeometries (geometries) {\n    this.setGeometriesArray(cloneGeometries(geometries));\n  };\n\n  /**\n   * @param {Array<Geometry>} geometries Geometries.\n   */\n  GeometryCollection.prototype.setGeometriesArray = function setGeometriesArray (geometries) {\n    this.unlistenGeometriesChange_();\n    this.geometries_ = geometries;\n    this.listenGeometriesChange_();\n    this.changed();\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  GeometryCollection.prototype.applyTransform = function applyTransform (transformFn) {\n    var geometries = this.geometries_;\n    for (var i = 0, ii = geometries.length; i < ii; ++i) {\n      geometries[i].applyTransform(transformFn);\n    }\n    this.changed();\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  GeometryCollection.prototype.translate = function translate (deltaX, deltaY) {\n    var geometries = this.geometries_;\n    for (var i = 0, ii = geometries.length; i < ii; ++i) {\n      geometries[i].translate(deltaX, deltaY);\n    }\n    this.changed();\n  };\n\n  /**\n   * @inheritDoc\n   */\n  GeometryCollection.prototype.disposeInternal = function disposeInternal () {\n    this.unlistenGeometriesChange_();\n    Geometry.prototype.disposeInternal.call(this);\n  };\n\n  return GeometryCollection;\n}(Geometry));\n\n\n/**\n * @param {Array<Geometry>} geometries Geometries.\n * @return {Array<Geometry>} Cloned geometries.\n */\nfunction cloneGeometries(geometries) {\n  var clonedGeometries = [];\n  for (var i = 0, ii = geometries.length; i < ii; ++i) {\n    clonedGeometries.push(geometries[i].clone());\n  }\n  return clonedGeometries;\n}\n\n\nexport default GeometryCollection;\n\n//# sourceMappingURL=GeometryCollection.js.map","/**\n * @module ol/geom/Point\n */\nimport {createOrUpdateFromCoordinate, containsXY} from '../extent.js';\nimport GeometryType from './GeometryType.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {deflateCoordinate} from './flat/deflate.js';\nimport {squaredDistance as squaredDx} from '../math.js';\n\n/**\n * @classdesc\n * Point geometry.\n *\n * @api\n */\nvar Point = /*@__PURE__*/(function (SimpleGeometry) {\n  function Point(coordinates, opt_layout) {\n    SimpleGeometry.call(this);\n    this.setCoordinates(coordinates, opt_layout);\n  }\n\n  if ( SimpleGeometry ) Point.__proto__ = SimpleGeometry;\n  Point.prototype = Object.create( SimpleGeometry && SimpleGeometry.prototype );\n  Point.prototype.constructor = Point;\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!Point} Clone.\n   * @override\n   * @api\n   */\n  Point.prototype.clone = function clone () {\n    var point = new Point(this.flatCoordinates.slice(), this.layout);\n    return point;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  Point.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {\n    var flatCoordinates = this.flatCoordinates;\n    var squaredDistance = squaredDx(x, y, flatCoordinates[0], flatCoordinates[1]);\n    if (squaredDistance < minSquaredDistance) {\n      var stride = this.stride;\n      for (var i = 0; i < stride; ++i) {\n        closestPoint[i] = flatCoordinates[i];\n      }\n      closestPoint.length = stride;\n      return squaredDistance;\n    } else {\n      return minSquaredDistance;\n    }\n  };\n\n  /**\n   * Return the coordinate of the point.\n   * @return {import(\"../coordinate.js\").Coordinate} Coordinates.\n   * @override\n   * @api\n   */\n  Point.prototype.getCoordinates = function getCoordinates () {\n    return !this.flatCoordinates ? [] : this.flatCoordinates.slice();\n  };\n\n  /**\n   * @inheritDoc\n   */\n  Point.prototype.computeExtent = function computeExtent (extent) {\n    return createOrUpdateFromCoordinate(this.flatCoordinates, extent);\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  Point.prototype.getType = function getType () {\n    return GeometryType.POINT;\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  Point.prototype.intersectsExtent = function intersectsExtent (extent) {\n    return containsXY(extent, this.flatCoordinates[0], this.flatCoordinates[1]);\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  Point.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {\n    this.setLayout(opt_layout, coordinates, 0);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    this.flatCoordinates.length = deflateCoordinate(\n      this.flatCoordinates, 0, coordinates, this.stride);\n    this.changed();\n  };\n\n  return Point;\n}(SimpleGeometry));\n\n\nexport default Point;\n\n//# sourceMappingURL=Point.js.map","/**\n * @module ol/geom/GeometryType\n */\n\n/**\n * The geometry type. One of `'Point'`, `'LineString'`, `'LinearRing'`,\n * `'Polygon'`, `'MultiPoint'`, `'MultiLineString'`, `'MultiPolygon'`,\n * `'GeometryCollection'`, `'Circle'`.\n * @enum {string}\n */\nexport default {\n  POINT: 'Point',\n  LINE_STRING: 'LineString',\n  LINEAR_RING: 'LinearRing',\n  POLYGON: 'Polygon',\n  MULTI_POINT: 'MultiPoint',\n  MULTI_LINE_STRING: 'MultiLineString',\n  MULTI_POLYGON: 'MultiPolygon',\n  GEOMETRY_COLLECTION: 'GeometryCollection',\n  CIRCLE: 'Circle'\n};\n\n//# sourceMappingURL=GeometryType.js.map","/**\n * @module ol/geom/Circle\n */\nimport {createOrUpdate, forEachCorner, intersects} from '../extent.js';\nimport GeometryType from './GeometryType.js';\nimport SimpleGeometry from './SimpleGeometry.js';\nimport {deflateCoordinate} from './flat/deflate.js';\n\n/**\n * @classdesc\n * Circle geometry.\n *\n * @api\n */\nvar Circle = /*@__PURE__*/(function (SimpleGeometry) {\n  function Circle(center, opt_radius, opt_layout) {\n    SimpleGeometry.call(this);\n    if (opt_layout !== undefined && opt_radius === undefined) {\n      this.setFlatCoordinates(opt_layout, center);\n    } else {\n      var radius = opt_radius ? opt_radius : 0;\n      this.setCenterAndRadius(center, radius, opt_layout);\n    }\n  }\n\n  if ( SimpleGeometry ) Circle.__proto__ = SimpleGeometry;\n  Circle.prototype = Object.create( SimpleGeometry && SimpleGeometry.prototype );\n  Circle.prototype.constructor = Circle;\n\n  /**\n   * Make a complete copy of the geometry.\n   * @return {!Circle} Clone.\n   * @override\n   * @api\n   */\n  Circle.prototype.clone = function clone () {\n    return new Circle(this.flatCoordinates.slice(), undefined, this.layout);\n  };\n\n  /**\n   * @inheritDoc\n   */\n  Circle.prototype.closestPointXY = function closestPointXY (x, y, closestPoint, minSquaredDistance) {\n    var flatCoordinates = this.flatCoordinates;\n    var dx = x - flatCoordinates[0];\n    var dy = y - flatCoordinates[1];\n    var squaredDistance = dx * dx + dy * dy;\n    if (squaredDistance < minSquaredDistance) {\n      if (squaredDistance === 0) {\n        for (var i = 0; i < this.stride; ++i) {\n          closestPoint[i] = flatCoordinates[i];\n        }\n      } else {\n        var delta = this.getRadius() / Math.sqrt(squaredDistance);\n        closestPoint[0] = flatCoordinates[0] + delta * dx;\n        closestPoint[1] = flatCoordinates[1] + delta * dy;\n        for (var i$1 = 2; i$1 < this.stride; ++i$1) {\n          closestPoint[i$1] = flatCoordinates[i$1];\n        }\n      }\n      closestPoint.length = this.stride;\n      return squaredDistance;\n    } else {\n      return minSquaredDistance;\n    }\n  };\n\n  /**\n   * @inheritDoc\n   */\n  Circle.prototype.containsXY = function containsXY (x, y) {\n    var flatCoordinates = this.flatCoordinates;\n    var dx = x - flatCoordinates[0];\n    var dy = y - flatCoordinates[1];\n    return dx * dx + dy * dy <= this.getRadiusSquared_();\n  };\n\n  /**\n   * Return the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.\n   * @return {import(\"../coordinate.js\").Coordinate} Center.\n   * @api\n   */\n  Circle.prototype.getCenter = function getCenter () {\n    return this.flatCoordinates.slice(0, this.stride);\n  };\n\n  /**\n   * @inheritDoc\n   */\n  Circle.prototype.computeExtent = function computeExtent (extent) {\n    var flatCoordinates = this.flatCoordinates;\n    var radius = flatCoordinates[this.stride] - flatCoordinates[0];\n    return createOrUpdate(\n      flatCoordinates[0] - radius, flatCoordinates[1] - radius,\n      flatCoordinates[0] + radius, flatCoordinates[1] + radius,\n      extent);\n  };\n\n  /**\n   * Return the radius of the circle.\n   * @return {number} Radius.\n   * @api\n   */\n  Circle.prototype.getRadius = function getRadius () {\n    return Math.sqrt(this.getRadiusSquared_());\n  };\n\n  /**\n   * @private\n   * @return {number} Radius squared.\n   */\n  Circle.prototype.getRadiusSquared_ = function getRadiusSquared_ () {\n    var dx = this.flatCoordinates[this.stride] - this.flatCoordinates[0];\n    var dy = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];\n    return dx * dx + dy * dy;\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  Circle.prototype.getType = function getType () {\n    return GeometryType.CIRCLE;\n  };\n\n  /**\n   * @inheritDoc\n   * @api\n   */\n  Circle.prototype.intersectsExtent = function intersectsExtent (extent) {\n    var circleExtent = this.getExtent();\n    if (intersects(extent, circleExtent)) {\n      var center = this.getCenter();\n\n      if (extent[0] <= center[0] && extent[2] >= center[0]) {\n        return true;\n      }\n      if (extent[1] <= center[1] && extent[3] >= center[1]) {\n        return true;\n      }\n\n      return forEachCorner(extent, this.intersectsCoordinate, this);\n    }\n    return false;\n\n  };\n\n  /**\n   * Set the center of the circle as {@link module:ol/coordinate~Coordinate coordinate}.\n   * @param {import(\"../coordinate.js\").Coordinate} center Center.\n   * @api\n   */\n  Circle.prototype.setCenter = function setCenter (center) {\n    var stride = this.stride;\n    var radius = this.flatCoordinates[stride] - this.flatCoordinates[0];\n    var flatCoordinates = center.slice();\n    flatCoordinates[stride] = flatCoordinates[0] + radius;\n    for (var i = 1; i < stride; ++i) {\n      flatCoordinates[stride + i] = center[i];\n    }\n    this.setFlatCoordinates(this.layout, flatCoordinates);\n    this.changed();\n  };\n\n  /**\n   * Set the center (as {@link module:ol/coordinate~Coordinate coordinate}) and the radius (as\n   * number) of the circle.\n   * @param {!import(\"../coordinate.js\").Coordinate} center Center.\n   * @param {number} radius Radius.\n   * @param {import(\"./GeometryLayout.js\").default=} opt_layout Layout.\n   * @api\n   */\n  Circle.prototype.setCenterAndRadius = function setCenterAndRadius (center, radius, opt_layout) {\n    this.setLayout(opt_layout, center, 0);\n    if (!this.flatCoordinates) {\n      this.flatCoordinates = [];\n    }\n    /** @type {Array<number>} */\n    var flatCoordinates = this.flatCoordinates;\n    var offset = deflateCoordinate(\n      flatCoordinates, 0, center, this.stride);\n    flatCoordinates[offset++] = flatCoordinates[0] + radius;\n    for (var i = 1, ii = this.stride; i < ii; ++i) {\n      flatCoordinates[offset++] = flatCoordinates[i];\n    }\n    flatCoordinates.length = offset;\n    this.changed();\n  };\n\n  /**\n   * @inheritDoc\n   */\n  Circle.prototype.getCoordinates = function getCoordinates () {\n    return null;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  Circle.prototype.setCoordinates = function setCoordinates (coordinates, opt_layout) {};\n\n  /**\n   * Set the radius of the circle. The radius is in the units of the projection.\n   * @param {number} radius Radius.\n   * @api\n   */\n  Circle.prototype.setRadius = function setRadius (radius) {\n    this.flatCoordinates[this.stride] = this.flatCoordinates[0] + radius;\n    this.changed();\n  };\n\n  return Circle;\n}(SimpleGeometry));\n\n\n/**\n * Transform each coordinate of the circle from one coordinate reference system\n * to another. The geometry is modified in place.\n * If you do not want the geometry modified in place, first clone() it and\n * then use this function on the clone.\n *\n * Internally a circle is currently represented by two points: the center of\n * the circle `[cx, cy]`, and the point to the right of the circle\n * `[cx + r, cy]`. This `transform` function just transforms these two points.\n * So the resulting geometry is also a circle, and that circle does not\n * correspond to the shape that would be obtained by transforming every point\n * of the original circle.\n *\n * @param {import(\"../proj.js\").ProjectionLike} source The current projection.  Can be a\n *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n * @param {import(\"../proj.js\").ProjectionLike} destination The desired projection.  Can be a\n *     string identifier or a {@link module:ol/proj/Projection~Projection} object.\n * @return {Circle} This geometry.  Note that original geometry is\n *     modified in place.\n * @function\n * @api\n */\nCircle.prototype.transform;\nexport default Circle;\n\n//# sourceMappingURL=Circle.js.map","/**\n * @module ol/geom/flat/segments\n */\n\n\n/**\n * This function calls `callback` for each segment of the flat coordinates\n * array. If the callback returns a truthy value the function returns that\n * value immediately. Otherwise the function returns `false`.\n * @param {Array<number>} flatCoordinates Flat coordinates.\n * @param {number} offset Offset.\n * @param {number} end End.\n * @param {number} stride Stride.\n * @param {function(this: S, import(\"../../coordinate.js\").Coordinate, import(\"../../coordinate.js\").Coordinate): T} callback Function\n *     called for each segment.\n * @param {S=} opt_this The object to be used as the value of 'this'\n *     within callback.\n * @return {T|boolean} Value.\n * @template T,S\n */\nexport function forEach(flatCoordinates, offset, end, stride, callback, opt_this) {\n  var point1 = [flatCoordinates[offset], flatCoordinates[offset + 1]];\n  var point2 = [];\n  var ret;\n  for (; (offset + stride) < end; offset += stride) {\n    point2[0] = flatCoordinates[offset + stride];\n    point2[1] = flatCoordinates[offset + stride + 1];\n    ret = callback.call(opt_this, point1, point2);\n    if (ret) {\n      return ret;\n    }\n    point1[0] = point2[0];\n    point1[1] = point2[1];\n  }\n  return false;\n}\n\n//# sourceMappingURL=segments.js.map"],"sourceRoot":""}